% Generated by Sphinx.
\def\sphinxdocclass{article}
\documentclass[letterpaper,10pt,english]{sphinxhowto}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{AstroLyze Documentation}
\date{July 08, 2013}
\release{0.1.0}
\author{Christof Buchbender}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index_pdf::doc}\begin{enumerate}
\setcounter{enumi}{12}
\item {} 
MapClass documentation master file, created by
sphinx-quickstart on Tue May 15 17:38:24 2012.
You can adapt this file completely to your liking, but it should at least
contain the root \emph{toctree} directive.

\end{enumerate}



Astrolyze is a python-package with several functions for reduction and analysis
of (mainly) radioastronomical data analysis. It is developed over the course of
my Diploma and PhD thesis. I decided to package the functions because I think
that they may be useful to other astronomers. The package is open for
collaboration.


\section{Installation of astrolyze}
\label{installation::doc}\label{installation:astrolyze-documentation}\label{installation:installation-of-astrolyze}
astrolyze is only tested on Linux/Ubuntu so far.


\subsection{Dependencies}
\label{installation:dependencies}

\subsubsection{Python}
\label{installation:python}
astrolyze depends on the following python packages

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}
\PYG{n}{pyfits}
\PYG{n}{matplotlib}
\PYG{n}{scipy}
\PYG{n}{pywcs}
\PYG{n}{pysqlite2}
\end{Verbatim}

In Ubuntu (and thus most probable also Debian) these dependencies can be
installed via:

\begin{Verbatim}[commandchars=\\\{\}]
sudo apt-get install python-matplotlib python-pywcs python-scipy python-numpy
python-pysqlite2 python-pyfits
\end{Verbatim}


\subsubsection{Gildas}
\label{installation:gildas}
To be able to use GILDAS from within astrolyze it is enough to have a working
GILDAS installation compiled with the python support. The actual GILDAS version
and installation instructions can be found here:

\href{http://www.iram.fr/IRAMFR/GILDAS/}{http://www.iram.fr/IRAMFR/GILDAS/}


\subsubsection{Miriad}
\label{installation:miriad}
Also Miriad just has to be installed and working. At the moment only the smooth
function of miriad is used in astrolyze but it is worth installing it since it
it a common task. Miriad and instructions for installation can be found here:

\href{ftp://ftp.atnf.csiro.au/pub/software/miriad/INSTALL.html}{ftp://ftp.atnf.csiro.au/pub/software/miriad/INSTALL.html}


\subsection{Installation}
\label{installation:installation}
If you are interested in the package please sent me a short E-Mail
(\href{mailto:buchbend@iram.es}{buchbend@iram.es}) and I'll send it to you. Later it will be available on-line.

So far it astrolyze is only available as a source distribution. To install
astrolyze unpack the tar-ball via:
\begin{quote}

\textgreater{} tar -xvzf astrolyze-0.1.0.tar.gz
\end{quote}

which will unpack into a directory `'astrolyze-0.1.0'' in the current path.
After entering this directory the installation of astrolyze is done via:

\begin{Verbatim}[commandchars=\\\{\}]
sudo python setup.py install
\end{Verbatim}

In the current state the setup does not allow a custom installation path. The
files will be installed depending on your system configuration in either of the
following locations:

\begin{Verbatim}[commandchars=\\\{\}]
/usr/lib/pythonX.Y/site-packages
/usr/local/lib/pythonX.Y/site-packages
\end{Verbatim}

Here X and Y are the major and minor number your python installations.


\subsection{Configuration of the (optional) Database}
\label{installation:configuration-of-the-optional-database}
The setup.py script will generate \code{parameter.db} sqlite database containing
information about the maps and files opened in astrolyzed. From the keyword of
the `'Naming Convention'`.

In the current state  astrolyze reads in
\begin{itemize}
\item {} 
Additional informations of the source

\item {} 
Frequencies and wavelengths

\item {} 
Calibration error for specific telescopes

\end{itemize}

The database has to be populated by the user. This is done via the three text
files in the \code{cfg} folder located in \code{astrolyze-0.1.0} that contains:

galaxy\_parameter.txt:

line\_parameter.txt:

calibration\_error.txt:

The Names of the source telescope and lines have to be exactly how they are
used in the map names. However the writing can be an arbitrary mix of upper an
lower case characters. Internally Astrolyze converts them to upper case before
comparing.


\section{Motivation}
\label{manual:motivation}\label{manual::doc}
First, before we delve into details, let me give some examples of what
astrolyze is capable of, so that you can decide if it could be of use for you.
This is a snapshot of some of the most powerful features of astrolyze; a
thorough introduction with more features and possibilities are given in the
\emph{label-naming-convention}.


\subsection{Inter-operating Fits, Gildas and Miriad}
\label{manual:inter-operating-fits-gildas-and-miriad}
Using the astrolyze package it is possible to use different file formats and
different programs from within python seamlessly. Say, for the sake of
demonstrations, that you have a Fits image called
\code{M33\_30m\_12CO10\_Tmb\_12.fits} and that you want to smooth it in miriad to 40
arcsec resolution, re-project it with Gildas to a new central coordinate and
finally convert it back to fits-format:

This is how you would do it with astrolyze:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{toMiriad}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{smooth}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{toGildas}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{reproject}\PYG{p}{(}\PYG{n}{coordinate}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{01:34:50.890}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+31:08:28.03}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{toFits}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Please note the special format of the map name. The format follows a certain
\code{naming convention} that has to be used with astrolyze. The reason for the
naming conventions and it's internal logic is explained below.

As a side note I use an underscore for the \code{map\_} variable, because
otherwise the python function \code{map} is overwritten which may lead to problems.


\subsection{Changing map units}
\label{manual:changing-map-units}
With astrolyze the units of a map can be quickly transformed between common
units used in (Radio-) Astronomy (as far as the conversion was implemented
already). Take for example again the \code{M33\_30m\_12CO10\_Tmb\_12.fits} map.
Following the naming convention this map is in main beam temperature
(Tmb). Changing its units to \code{JyB} is as easy as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{change\PYGZus{}unit}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JyB}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Another side note: It's only that easy when astrolyze is set-up
correctly as described in TODO. Link to Installation.  Also please check the
results for plausibility in case there are faults in the internal conversion
algorithms.


\subsection{Working with stacks of images}
\label{manual:working-with-stacks-of-images}
The previous examples show the principles how a single map can be treated in
astrolyze. However the package also includes a way to work on a stack of images
and perform tasks on all of them.

To create a stack, all files that are going to be in the stack have to be
located in one folder (with possible sub-folders NOTE: The functionality with
sub-folders are is however not thoroughly tested however.)
A stack is initialized as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{example\PYGZus{}stack} \PYG{o}{=} \PYG{n}{Stack}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path\PYGZus{}to\PYGZus{}folder}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The maps can be a mix of GILDAS, Fits and MIRIAD maps. The Instance of the
Stack object (here: \code{example\_stack}) contains a variable called stack which
is a list with Instances of the corresponding maps Objects (GildasMap, FitsMap
and MiriadMap).

The stack module provides several tools to \code{unify} the stack for further
analysis. The maps can be all re-gridded and re-projected to the same central
coordinates, pixel-sizes and dimensions as a given template image via:

\begin{Verbatim}[commandchars=\\\{\}]
example\_stack.unify\_dimensions(template='path\_to\_template\_file',
                folder='path\_to\_output\_folder') .
\end{Verbatim}

Also the maps can be all smoothed to the same resolution, by default this is
the largest resolution found in the stack but can also be given manually:

\begin{Verbatim}[commandchars=\\\{\}]
example\_stack.unify\_resolutions(folder='path\_to\_output\_folder') .
\end{Verbatim}

Astrolyze includes also some unit conversions that can be used to change all
maps to the same resolutions as long as the input and output units are
programmed. See (TODO) for more details. For the stack:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{example\PYGZus{}stack}\PYG{o}{.}\PYG{n}{unify\PYGZus{}units}\PYG{p}{(}\PYG{n}{folder}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path\PYGZus{}to\PYGZus{}output\PYGZus{}folder}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{p}{,}
\end{Verbatim}

can be used.


\subsection{Producing SEDs}
\label{manual:producing-seds}
Build on-top of the stack module astrolyze also contains an \code{sed} module
which allows to analyze and plot dust-seds. The SEDs can be read out for an
arbitrary number of positions or for a full maps. In the latter case
temperature and mass maps will be created.

When all maps have the same resolution and dimension (i.e. pixel size and
number) producing temperature maps can be done as follows:

\begin{Verbatim}[commandchars=\\\{\}]
from astrolyze import *
sed = SedStack(folder='path\_to\_input\_folder', full\_map=True,
       output\_folder='path\_to\_output\_folder') .
\end{Verbatim}

To generate SEDs at given coordinates it is easiest to provide a separate file
(e.g. \code{coordinates.txt})with the names and coordinates of the positions to be
extracted as follows:

\begin{Verbatim}[commandchars=\\\{\}]
source\_1    1:34:7.00     +30:47:52.00
source\_2    1:33:55.80    +30:43:2.00
source\_3    1:33:52.40    +30:39:18.00
  .              .             .
  .              .             .
  .              .             .
\end{Verbatim}

Then a stack of seds can be created:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{seds} \PYG{o}{=} \PYG{n}{SedStack}\PYG{p}{(}\PYG{n}{folder}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path\PYGZus{}to\PYGZus{}input\PYGZus{}folder}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flux\PYGZus{}acquisition}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

By default the SED is also directly fitted. One can produce a quick preview
plot of the SEDs via:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{seds}\PYG{o}{.}\PYG{n}{sed\PYGZus{}stack}\PYG{p}{:}
    \PYG{n}{i}\PYG{o}{.}\PYG{n}{create\PYGZus{}figure}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsection{Not only images ...}
\label{manual:not-only-images}
Last but not least astrolyze is also able to work with 30m class spectra from
within python based on the same principles used to work with images/maps. The
implementation makes extensive use of {\color{red}\bfseries{}pyGildas\_}.  For example if you have a
file with the spectra of a cube, e.g. \code{M33\_30m\_12CO10\_Tmb\_21\_cube.30m} you
can extract the spectra that corresponds closest to a given variable as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{spectra} \PYG{o}{=} \PYG{n}{ClassSpectra}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}21\PYGZus{}cube.30m}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{coordinate} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1:34:7.00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+30:47:52.00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{spectrum} \PYG{o}{=} \PYG{n}{spectra}\PYG{o}{.}\PYG{n}{get\PYGZus{}spectra\PYGZus{}from\PYGZus{}cube}\PYG{p}{(}\PYG{n}{coordinate}\PYG{p}{)}
\PYG{c}{\PYGZsh{} To show the spectrum in the Class window}
\PYG{n}{spectrum}\PYG{o}{.}\PYG{n}{quick\PYGZus{}view}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\bigskip\hrule{}\bigskip



\section{Manual}
\label{manual:label-manual}\label{manual:manual}
This manual explains how astrolyze can be used to ease reduction,
analysis and modification of (radio-) astronomical data and images.

I started to develop astrolyze to be able to inter-operate the Programs PyFits,
MIRIAD and GILDAS. One reason was that the Gildas task are very cumbersome to
script and once scripted, the scripts are not very flexible. Also there are
some tasks in GILDAS that are (in my opinion) easier to use than in miriad and
vice-versa, due to different sets of features.

However, the real power of astrolyze comes from it's internal tracking of
changes to the most important parameters of the maps (or spectral-files), which
are stored directly in the file-names, following a naming-convention as well as
additional databases, from that more informations can be loaded depending on
the file-name-keywords.
\phantomsection\label{manual:label-naming-convention}
A Name that follows the `Naming Convention' is for example:
\code{M33\_30m-HERA\_CO21\_Ta*\_12\_cube\_regrid.fits}

All items \textbf{MUST} be separated by an underscore (\_) and \textbf{HAVE} to include at
the following properties in the same order:
\begin{enumerate}
\item {} 
source

\item {} 
telescope

\item {} 
species (wavelength OR frequency OR line-name)

\item {} 
flux unit

\item {} 
resolution

\end{enumerate}

When opening a map with astrolyze these items are transferred to python
variables of the \emph{Map class} (see below).  All additional items
separated by underscores are treated as comments. Comments are not
transferred to individual internal variables of the map objects but are passed
on as a list to the single variable comments.

The last item is followed by the files extension:
\begin{itemize}
\item {} 
.fits -\textgreater{} FITS

\item {} 
.gdf, .mean, .velo, .width, .lmv -\textgreater{} GILDAS

\item {} 
nothing -\textgreater{} MIRIAD (Miriads file format uses directories to store the data.)

\end{itemize}

Maps that are not following this name convention are \textbf{not} supported. This is
to assure that all parts of the program work, since they strongly depend on the
parameters passed on by the file-name, as is explained in this tutorial or the
documentation of the functions.

Using the example file-name above, opening this file with astrolyze as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{map\PYGZus{}} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12\PYGZus{}cube\PYGZus{}regrid.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

would generate the following python variables:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{source} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{telescope} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{30m}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{species} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{12CO10}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{fluxUnit} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tmb}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{resolution} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{12}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{comments} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cube}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{regrid}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{map\PYGZus{}}\PYG{o}{.}\PYG{n}{dataFormat} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fits}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

Using one parameter database with line-names, objects and telescope parameters
which can be edited by the user (see {\hyperref[installation::doc]{\emph{Installation of astrolyze}}}), astrolyze is able to
pull more information about the object, telescope and line emission of the
map. When the information is present it generates automatically the following
variables:

\begin{Verbatim}[commandchars=\\\{\}]
map\_.frequency [Hz]
map\_.wavelength [m]
map\_.calibrationError
map\_.type [Hubble Type]
map\_.distance [pc]
map\_.vlsr [km/s]
map\_.centralPosition [RA, DEC] J2000
map\_.pa [degrees]
map\_.inclination [degrees]
map\_.R25 [kpc]
\end{Verbatim}

If not present in the database these variables are set to `NaN' (Not a Number).

Although, all of this information is somewhat redundant to the header
information in the files, it has been decided to go that way since
unfortunately not all headers are kept up to date and manipulating the file
name is easier to do.

The maps module tries to keep track if a variable that should go into the
header of a fits file is changed and up-dates the header subsequently (Maybe
not true in all cases, though.).

Last but not least using this name convention has another benefit since it
makes the life of your fellow astronomers easier when they have to work with
your data since they readily know their most important basic properties.


\section{Modules}
\label{manual:modules}
astrolyze is divided in different modules and classes which can inter-operate
with each other and which are:
\begin{itemize}
\item {} 
maps

\item {} 
spectra

\item {} 
sed

\item {} 
functions

\item {} 
lte

\end{itemize}

In the following I will introduce the individual modules of astrolyze and their
functionality.

Not all functions of the individual astrolyze modules will be covered in this
manual-page. All functions are documented and can be found HERE TODO.  The next
sections attempts to show the basis principles, structure and work-flow of
astrolyze.


\bigskip\hrule{}\bigskip



\section{maps}
\label{manual:maps}
The \code{maps} module is the heart of the astrolyze package. It provides the
framework to work with astronomical images (and spectra). It is able to modify
and to track the most important properties of the maps such that they are always
fast at hand if needed. Further it contains genuine functions written in python
(and pyGildas), alongside wrapper functions to functions and tasks of {\hyperref[manual:gildas]{GILDAS}}
and {\hyperref[manual:miriad]{MIRIAD}}.

The \code{maps} module contains the following modules/Classes itself:
\begin{itemize}
\item {} 
main.Main

\item {} 
fits.FitsMap

\item {} 
gildas.GilsdasMap

\item {} 
miriad.MiriadMap

\item {} 
stack.Stack

\item {} 
tools

\end{itemize}


\bigskip\hrule{}\bigskip



\section{main}
\label{manual:main}
This module contains the class: \code{Main}, which
is the parent class for all actions not depending on the actual data-type. In
principle it is the implementation of the \emph{label-naming-convention} and is
not directly used to open a map. All other classes in maps inherit from the
\code{Main} class, such that it is used any time
the other modules of maps are used. Also the {\hyperref[manual:label-sed-module]{\emph{Using the sed module}}} uses Main.

When opening a map with \code{Main} variables are
created that contain information about the maps and can be used to work with
the data. The variables are class attributes. They can be accessed by attaching
them to the object with a dot between object and attribute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{object}\PYG{o}{.}\PYG{n}{attribute}
\end{Verbatim}

In astrolyze the maps that are opened are objects. The information for the
variables come from different places:


\subsection{From naming convention}
\label{manual:from-naming-convention}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{map\PYGZus{}name}
\PYG{n}{prefix}
\PYG{n}{source}
\PYG{n}{telescope}
\PYG{n}{species}
\PYG{n}{fluxUnit}
\PYG{n}{resolution}
\PYG{n}{comments}
\PYG{n}{dataFormat}
\end{Verbatim}


\subsubsection{Calculated Values}
\label{manual:calculated-values}
Assuming a Gaussian beam size the following variables are calculates from the
\code{resolution} keyword.

\begin{Verbatim}[commandchars=\\\{\}]
beamSizeM2       Beam-Size in m\textasciicircum{}2
beamSizeSterad   Beam-Size in sterad
\end{Verbatim}


\subsubsection{Known Format endings of the different file types}
\label{manual:known-format-endings-of-the-different-file-types}
These variables contain a list that contain all strings that are recognized by
the system as a valid file name ending (TODO: find the correct name for file
ending).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fits\PYGZus{}formats}
\PYG{n}{miriad\PYGZus{}formats}
\PYG{n}{gildas\PYGZus{}formats}
\PYG{n}{class\PYGZus{}formats}
\end{Verbatim}

\begin{notice}{warning}{Warning:}
These are hard-coded, should be initialized via the cfg/ folder of the
package when installing.
\end{notice}


\subsection{Variables loaded from Database}
\label{manual:variables-loaded-from-database}
As explained in TODO. Astrolyze uses a database to store additional
informations  about maps. The database is set-up during installation as
explained in {\hyperref[installation::doc]{\emph{Installation of astrolyze}}}.


\subsubsection{From Line Database}
\label{manual:from-line-database}
Using the \code{species} keyword:

\begin{Verbatim}[commandchars=\\\{\}]
frequency  : [GHz]
wavelength : [TODO]
\end{Verbatim}


\subsubsection{From Galaxy Database}
\label{manual:from-galaxy-database}
Using the \code{source} keyword.:

\begin{Verbatim}[commandchars=\\\{\}]
centralPosition : [RA, DEC]
distance : [kpc]
R25 : [kpc TODO]
inclination : [degrees]
vlsr : [km/s]
pa : [degrees]
type :  The Hubble type of the galaxy.
\end{Verbatim}


\subsubsection{From Calibration Database}
\label{manual:from-calibration-database}
Using the \code{species} and \code{telescope} keywords.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{calibrationError}
\end{Verbatim}


\bigskip\hrule{}\bigskip


The in-depth documentation of the internal functions can be found here
\emph{main-label}.


\bigskip\hrule{}\bigskip



\section{fits}
\label{manual:fits}
The fits module contains the class \code{FitsMap}. This class inherits all functions from
\code{Main} but adds functionality and methods
needed to work with fits data. This class makes use of the {\hyperref[manual:python-pyfits]{python-pyfits}}
package. Please check the pyfits web-page (follow the previous link) for the
pyfits documentation.

To open a fits-map do, e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}
\phantomsection\label{manual:label-fits-variables}
Opening a Fits map creates, besides the variables discussed in
\emph{main-label} the following additional variables specific to the
\code{FitsMap}:


\subsection{Variables loaded with pyfits}
\label{manual:variables-loaded-with-pyfits}
\begin{Verbatim}[commandchars=\\\{\}]
header : a dictionary with the fits-header cards
data : numpy.ndarray containing the data
hdulist : Some fits-files have more than one plane. HDUlist contains all
      planes.
\end{Verbatim}


\subsection{Calculated values}
\label{manual:id1}
Because the fits-header is read via {\hyperref[manual:python-pyfits]{python-pyfits}} the pixel dimensions are
known and thus the pixel-sizes can be caluclated:

\begin{Verbatim}[commandchars=\\\{\}]
pixelSizeM2 : [m\textasciicircum{}2]
pixelSizeSterad [sterad] .
\end{Verbatim}


\subsection{Known header keywords}
\label{manual:known-header-keywords}
\begin{Verbatim}[commandchars=\\\{\}]
headerKeywords : A dictionary containing different fits-header keywords that
         are used for the same quantity.
\end{Verbatim}


\subsection{Known names of units}
\label{manual:known-names-of-units}
The \code{FitsMap} class contains the
method \code{change\_unit} which is able to
check the conversion that is needed to change to the desired unit. However for
this another \code{Unit Naming Convention} is needed. The following variables
contain lists of valid names for certain variables:

\begin{Verbatim}[commandchars=\\\{\}]
tmb\_names
jansky\_beam\_names
MJy\_per\_sterad\_names
erg\_sec\_pixel\_names
erg\_sec\_beam\_names
jansky\_pixel\_names
erg\_sec\_sterad\_names
known\_units .
\end{Verbatim}

\begin{notice}{warning}{Warning:}
This should also be setup during installation of astrolyze to be able to
customize unit-names easily.
\end{notice}
\phantomsection\label{manual:label-change-format}

\subsection{Changing Formats}
\label{manual:label-change-formats}\label{manual:changing-formats}
\begin{notice}{note}{Note:}
Changing formats works the same way in all \code{maps} modules.
\end{notice}

The loaded fits map can be transformed to the Gildas and Miriad Formats via the
methods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{toGildas}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{toMiriad}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

and from either of the other two Formats to Fits via:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{toFits}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This creates a copy of the image in the Gildas, Miriad (or Fits) Format on the
disk in the same folder as the actual map. To keep working with the map in the
new format one can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{toGildas}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

to change the out-put folder there are two ways:

\begin{Verbatim}[commandchars=\\\{\}]
1. Set the {}`{}`map.prefix{}`{}` variable to the new path prior to
   changing the map format as shown above.
2. Give the new path to the function, e.g. map.toGildas(folder='new\_path')
\end{Verbatim}

Thus e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{prefix} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{new\PYGZus{}path}\PYG{l+s}{\PYGZsq{}}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{toGildas}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{toGildas}\PYG{p}{(}\PYG{n}{folder}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{new\PYGZus{}path}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\subsection{Making use of Pyfits}
\label{manual:making-use-of-pyfits}
As listed in \emph{label-fits-variables} a \code{data} and a \code{header}
variable is created. These are a numpy.ndarray of the image data and a
dictionary containing the header keywords with their arguments. Thus changing
the properties of the fits map and the header variables is straight-forward.

For example you may want to change the units of a map
\code{M33\_30m\_12CO10\_Tmb\_12.fits} that is in main beam temperature to Jansky/beam
by multiplying all pixels with the corresponding conversion factor. This can be
done via:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{conversion\PYGZus{}factor} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{flux\PYGZus{}conversion}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{data} \PYG{o}{*} \PYG{n}{conversion\PYGZus{}factor}
\end{Verbatim}

The conversion factor between the two units is calculated here via
\code{flux\_conversion} please refer to
the function fro more details.

Having changed the unit it may be a good idea to change the header variables
that stores the actual unit as well as the unit-keyword from the naming
convention., this can be done as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{header}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BUNIT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{unit} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JyB}\PYG{l+s}{\PYGZsq{}}
\PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{header}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BUNIT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jy/beam}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
The individual functions in of the \code{FitsMap}-class change the header of
the Fits file automatically if map properties are changed. At the same time
they have access to all fits-header variables if needed.
\end{notice}

Finally you may want to save the modified image as a new fits file which can be
done with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{updateFile}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This creates a file called M33\_30m\_12CO10\_JyB\_12.fits


\subsection{Change Map Units}
\label{manual:change-map-units}
Since it is easy to modify all pixel via {\hyperref[manual:python-pyfits]{python-pyfits}} the function
\code{change\_unit} that converts
units into another is implemented in the \code{FitsMap}-class. See the
documentation of \code{change\_unit}
for the conversions that are implemented.

Using the information from the ``Naming Convention'' and the additional
information from the database, the code has all information to calculate the
conversion factors. And also to decide which conversion is to be
applied. Changes are possible between any of the units that are implemented.

\begin{notice}{warning}{Warning:}
This is not thoroughly tested yet!!
\end{notice}

For example the same change of units as in the previous section can be done as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{FitsMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.fits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n+nb}{map}\PYG{o}{.}\PYG{n}{change\PYGZus{}unit}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JyB}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\bigskip\hrule{}\bigskip



\section{Using gildas}
\label{manual:using-gildas}
When Opening a Gildas map with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{GildasMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.gdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{p}{,}
\end{Verbatim}

astrolyze uses pyGildas to read some of the header variables and stores them as
python variables. The following values are read.


\subsection{Variables}
\label{manual:variables}

\subsubsection{Gildas Specific}
\label{manual:gildas-specific}
\begin{Verbatim}[commandchars=\\\{\}]
dimensions
naxis\_1 : number of pixels in x-axis.
naxis\_2 : number of pixels in y-axis.

crpix\_1 : The reference pixel (x-axis).
crval\_1 : The coordinate value at crpix\_1 [radians].
cdelt\_1 : The pixel increment.

crpix\_2 : Same as crpix\_1 for y-axis.
crval\_2 : Same as crval\_1 for y-axis.
cdelt\_2 : Same as crdelt\_1 for y-axis.

ra\_coordinate : RA coordinate.
dec\_coordinate : DEC coordinate

ra\_coordinate : TODO
dec\_coordinate : TODO

central\_coordinate\_degrees : TODO
central\_coordinate\_equatorial : TODO
\end{Verbatim}

\begin{notice}{note}{Note:}
If needed more variables can be loaded when opening a Gildas map without
problems , so far only those that were needed are implemented.
\end{notice}


\bigskip\hrule{}\bigskip



\paragraph{How is Gildas used by astrolyze}
\label{manual:how-is-gildas-used-by-astrolyze}
Gildas is used in two different ways in Atrolyze:

\begin{Verbatim}[commandchars=\\\{\}]
1. A Gildas script, with a final exit at the end is created and executed via
   the os python package, sending commands to the bash.
2. The pyGildas package is used directly by astrolyze to tun command in SIC.
\end{Verbatim}

The first method is mainly used to wrap GREG (and maybe later CLASS) tasks
since these are cumbersome to script so far in Gildas. To do so the GildasMap
method create an \code{init} file and a temporary Greg script that is (normally)
deleted after execution. The standard script looks as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{exit}
\end{Verbatim}


\subsection{Wrapping Gildas Tasks}
\label{manual:wrapping-gildas-tasks}

\subsection{Direc use of pyGildas}
\label{manual:direc-use-of-pygildas}

\section{Using miriad}
\label{manual:using-miriad}
A miriad map is opened with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{astrolyze} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n+nb}{map} \PYG{o}{=} \PYG{n}{GildasMap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{M33\PYGZus{}30m\PYGZus{}12CO10\PYGZus{}Tmb\PYGZus{}12.gdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{p}{,}
\end{Verbatim}

In this mode only the variables created by \code{main} are created.

Only the \code{"smooth"} function from miriad is implemented in astrolyze see
\code{smooth()}.  When all header
variables are set correctly this function is aware of the map units and beam
sizes and can calculate the correct scaling that has to be applied after
convolution. The way astrolyze is set up the smooth function expects the map
to be in units of \code{Jy/beam}.

\begin{notice}{warning}{Warning:}
Miriad could be excluded from astrolyze in the future if the GILDAS smooth
wrapper is programmed such that it is aware of different input variables.
\end{notice}


\bigskip\hrule{}\bigskip



\section{Using the stack module}
\label{manual:using-the-stack-module}
The \code{Stack} class builds on top of the
classes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Main}
\PYG{n}{FitsMap}
\PYG{n}{GildasMap}
\PYG{n}{MiriadMap}
\end{Verbatim}

It provides the possibility to load a ``stack'' of maps inside a folder at once
and perform changes on all maps. It's intention is mainly to provide means to
unify maps for further processing. Tasks such as for example pixel-to-pixel
comparisons or the creation of temperature-maps from SED-fits needs individual
maps to be on the same resolution and/or the same pixel grid.
\begin{itemize}
\item {} 
\end{itemize}


\section{Using the sed module}
\label{manual:using-the-sed-module}\label{manual:label-sed-module}
The module SED makes extensive use of the stack functionality of the maps
module...

The module \code{functions} contains all functions that are not directly related
to manipulation of maps or spectra and counter intuitive also all constants used
in astrolyze as long as they are not available by the standard python
installation (this may not be true however.).

\begin{thebibliography}{python-pyfits}
\bibitem[GILDAS]{GILDAS}{\phantomsection\label{manual:gildas} 
\href{http://www.iram.fr/IRAMFR/GILDAS}{http://www.iram.fr/IRAMFR/GILDAS}
}
\bibitem[MIRIAD]{MIRIAD}{\phantomsection\label{manual:miriad} 
\href{http://www.atnf.csiro.au/computing/software/miriad/taskindex.html}{http://www.atnf.csiro.au/computing/software/miriad/taskindex.html}
}
\bibitem[python-pyfits]{python-pyfits}{\phantomsection\label{manual:python-pyfits} 
\href{http://www.stsci.edu/institute/software\_hardware/pyfits}{http://www.stsci.edu/institute/software\_hardware/pyfits}
}
\end{thebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
