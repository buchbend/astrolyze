

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MapClass &mdash; AstroLyze 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="AstroLyze 0.1.0 documentation" href="index.html" />
    <link rel="prev" title="Documentation of AstroLyze" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Documentation of AstroLyze"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">AstroLyze 0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-astrolyze.mapclass">
<span id="mapclass"></span><h1>MapClass<a class="headerlink" href="#module-astrolyze.mapclass" title="Permalink to this headline">¶</a></h1>
<p>The Map class is the parent class for the handling of astronomical map files 
in the FITS, GILDAS and MIRIAD data formats.
It is meant to make handling maps easier by wrapping functions of GILDAS and 
MIRIAD and providing new functions in python on the basis of pyfits.
It is using a &#8216;Name Convention&#8217; for ease of use. Meaning that the file name 
already includes basic information about the map it contains. A Name that 
follows this &#8216;Convention&#8217; is eg:</p>
<p>M33_30m-HERA_CO21_Ta*_12_cube.fits</p>
<p>All items <strong>MUST</strong> be seperated by an undescore (_) and have to include at 
minimum the following properties:</p>
<ol class="arabic simple">
<li>source</li>
<li>telescope</li>
<li>wavelength OR frequency OR lineName</li>
<li>flux unit</li>
<li>resolution</li>
</ol>
<p>Additionaly the map Class recognizes all following items as comments. In the 
name example above the comment be &#8220;cube&#8221;. Comments are not transfered to 
internal variables of the map objects.</p>
<p>The last item is followed by the files extension:</p>
<ul class="simple">
<li>.fits -&gt; FITS</li>
<li>.gdf -&gt; GILDAS</li>
<li>nothing -&gt; MIRIAD (Miriads file format uses directories to store the data)</li>
</ul>
<p>Maps that are not following this name convention are not supported 
to assure that all parts of the program work, since they mostly 
depend on the items set as will be explained below.</p>
<p>Also it makes the life of your fellow astronomers easier when they have to work with your data since they directly know their basic properties.</p>
<div class="section" id="mapclassmain">
<h2>MapClassMain<a class="headerlink" href="#mapclassmain" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astrolyze.mapclass.mapClassMain.Map">
<em class="property">class </em><tt class="descclassname">astrolyze.mapclass.mapClassMain.</tt><tt class="descname">Map</tt><big>(</big><em>mapName</em>, <em>nameConvention=True</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMain.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent Class with functions common to all three data Formats fits, Gildas
and Miriad.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="astrolyze.mapclass.mapClassMain.Map.changeMapName">
<tt class="descname">changeMapName</tt><big>(</big><em>source=None</em>, <em>telescope=None</em>, <em>species=None</em>, <em>fluxUnit=None</em>, <em>resolution=None</em>, <em>comments=None</em>, <em>dataFormat=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMain.Map.changeMapName" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can be used to change the names of the maps and make a
copy of the file to the new name and/or location.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassMain.Map.flux_conversion">
<tt class="descname">flux_conversion</tt><big>(</big><em>x=None</em>, <em>major=None</em>, <em>minor=None</em>, <em>nu_or_lambda='nu'</em>, <em>direction=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMain.Map.flux_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulates conversion between K.km/s and Jy/beam and vise versa.</p>
<dl class="docutils">
<dt>x: float [GHz]</dt>
<dd>Wavelenght/frequency. Defaults to the frequency of the loaded map,
i.e. self.frequency</dd>
<dt>major: float</dt>
<dd>Major Axis Beam (arcsec). Default None, i.e. using self.resolution.</dd>
<dt>minor: float</dt>
<dd>Minor Axis Beam(arcsec). Default None, i.e. using self.resolution.</dd>
<dt>nu_or_lambda: string</dt>
<dd>Choose type of x: frequency = <tt class="docutils literal"><span class="pre">'nu'</span></tt> or wavelenght =
<tt class="docutils literal"><span class="pre">'lambda'</span></tt>.</dd>
<dt>direction: string</dt>
<dd>choose conversion direction <tt class="docutils literal"><span class="pre">'kelvin_to_jansky'</span></tt>
means Kelvin to Jansky; <tt class="docutils literal"><span class="pre">'jansky_to_kelvin'</span></tt> Jansky to Kelvin.</dd>
</dl>
<p class="rubric">Notes</p>
<p>Please note that if self.frequency and self.resolution are correctly
set, this functions does not need any input.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassMain.Map.returnName">
<tt class="descname">returnName</tt><big>(</big><em>source=None</em>, <em>telescope=None</em>, <em>species=None</em>, <em>fluxUnit=None</em>, <em>resolution=None</em>, <em>comments=None</em>, <em>dataFormat=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMain.Map.returnName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Name corresponding to the Name convention. Single keywords
can be changed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapclassfits">
<h2>MapClassFits<a class="headerlink" href="#mapclassfits" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap">
<em class="property">class </em><tt class="descclassname">astrolyze.mapclass.mapClassFits.</tt><tt class="descname">FitsMap</tt><big>(</big><em>mapName</em>, <em>nameConvention=True</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits Map manipulation making extensive use of the
pyfits package.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.change_unit">
<tt class="descname">change_unit</tt><big>(</big><em>final_unit</em>, <em>frequency=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.change_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the unit of a map in an automated way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>final_unit: string</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>The unit to change the map to. Possible are:</dt>
<dd><ol class="first last arabic simple">
<li>Jy/beam: <tt class="docutils literal"><span class="pre">&quot;JyB&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;Jy/Beam&quot;</span></tt></li>
<li>Jy/pixel: <tt class="docutils literal"><span class="pre">&quot;JyP&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;JyPix&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;JyPix&quot;</span></tt></li>
<li>MJy/sterad: <tt class="docutils literal"><span class="pre">&quot;MJyPsr&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;MJy/sr&quot;</span></tt></li>
<li>Temperature: <tt class="docutils literal"><span class="pre">&quot;Tmb&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;T&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;Kkms&quot;</span></tt></li>
</ol>
</dd>
</dl>
</div></blockquote>
<p><strong>frequency: float</strong> :</p>
<blockquote class="last">
<div><p>Can be used if self.frequency is NaN. The frequency is needed
for conversions between temperature and Jansky/Erg scale.
Others don&#8217;t need it.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is still in developement and not all 
conversions may work properly.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.cut_map">
<tt class="descname">cut_map</tt><big>(</big><em>x1y1</em>, <em>x2y2</em>, <em>pix_or_coord='coord'</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.cut_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Cutting an rectangle out of a map. Giving the corners in
coordinates or in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x1y1: list</strong> :</p>
<blockquote>
<div><p>The upper right corner of the rectangle to cut out. 
Either in:</p>
<blockquote>
<div><ul class="simple">
<li>pixel coordinated [x1, y1]</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Or:</dt>
<dd><ul class="first last simple">
<li>equatorial coordinates [&#8216;RA&#8217;,&#8217;DEC&#8217;]</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p><strong>x2y2: list</strong> :</p>
<blockquote>
<div><p>The lower left corner in the same format as x1y1.</p>
</div></blockquote>
<p><strong>pix_or_coord: string</strong> :</p>
<blockquote class="last">
<div><p>Either <tt class="docutils literal"><span class="pre">&quot;pix&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;coord&quot;</span></tt> choosing what <strong>x1y1</strong>
and <strong>x2y2</strong> represents.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This procedure cuts only rectangles paralell to the sides of the map.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Old function. Functionality not guaranteed. maybe not really useful. 
Test or remove.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.gauss_factor">
<tt class="descname">gauss_factor</tt><big>(</big><em>beamConv</em>, <em>beamOrig=None</em>, <em>dx1=None</em>, <em>dy1=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.gauss_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluclates the scaling factor to be applied after convolving
a map in Jy/beam with a gaussian to get fluxes in Jy/beam again.</p>
<p>This function is a copy of the FORTRAN gaufac function from the Miriad
package, which determine the Gaussian parameters resulting from 
convolving two gaussians. This function yields the same result as 
the MIRIAD gaufac function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>beamConv: list</strong> :</p>
<blockquote>
<div><p>A list of the [major axis, minor axis, position_angle]
of the gaussion used for convolution.</p>
</div></blockquote>
<p><strong>beamOrig:</strong> :</p>
<blockquote>
<div><p>Same format as beamConv but giving the parameters of the original
beam of the map. As Default the self.resolution list is used.</p>
</div></blockquote>
<p><strong>dx1, dy1: floats</strong> :</p>
<blockquote>
<div><p>Being the pixel size in both dimensions of the map.
By default the <tt class="docutils literal"><span class="pre">CDELT1</span></tt> and <tt class="docutils literal"><span class="pre">CDELT2</span></tt> keywords from the 
fits header are used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>fac:</strong> :</p>
<blockquote>
<div><p>Factor for the output Units.</p>
</div></blockquote>
<p><strong>amp:</strong> :</p>
<blockquote>
<div><p>Amplitude of resultant gaussian.</p>
</div></blockquote>
<p><strong>bmaj, bmin:</strong> :</p>
<blockquote>
<div><p>Major and minor axes of resultant gaussian.</p>
</div></blockquote>
<p><strong>bpa:</strong> :</p>
<blockquote class="last">
<div><p>Position angle of the resulting gaussian.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.get_beam_size">
<tt class="descname">get_beam_size</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.get_beam_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulates the Beamsize in m^2 if distance is given
if it is not given the PixelSize is in sterradian.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.get_data">
<tt class="descname">get_data</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a self.data variable containing an array with the maps data. 
This function is automatically executed every time a Fits map is opened</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.get_header">
<tt class="descname">get_header</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.get_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a self.header variable containing an dictionary with the header 
information of the map. This function is automatically executed every 
time a Fits map is opened.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.get_pixel_size">
<tt class="descname">get_pixel_size</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.get_pixel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulates the Area of a pixel in m^2 if distance is given
if it is not given the PixelSize is in sterradian.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.pix2sky">
<tt class="descname">pix2sky</tt><big>(</big><em>pixel</em>, <em>degrees_or_equatorial='degrees'</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.pix2sky" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Coordinates of a given Pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>pixel: list</strong> :</p>
<blockquote>
<div><p>Pixel of the map; [x, y].</p>
</div></blockquote>
<p><strong>degrees_or_equatorial: string</strong> :</p>
<blockquote>
<div><p>Either <tt class="docutils literal"><span class="pre">&quot;degrees&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;equatorial&quot;</span></tt>. Choosing the
Format of the coordintates to be returnes.
Defaults to <tt class="docutils literal"><span class="pre">&quot;degrees&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coordinate: list</strong> :</p>
<blockquote class="last">
<div><p>The coordinates corresponding to pixel. Either in Degrees or in
Equatorial coordinates, depending on the parameter 
<em>degrees_or_equatorial</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.read_aperture">
<tt class="descname">read_aperture</tt><big>(</big><em>position</em>, <em>apertureSize=0</em>, <em>backgroundSize=0</em>, <em>output=False</em>, <em>annotation=False</em>, <em>newAnnotation=False</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.read_aperture" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the flux inside an aperture.</p>
<p>This function can be used to read the flux in the area of a 
circular/gaussian beam solid angle, as well as to correct for the 
background flux.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>position: list</strong> :</p>
<blockquote>
<div><p>The position in RA,DEC where the aperture is to be applied.
The Format has to be either:</p>
<blockquote>
<div><ul class="simple">
<li>[&#8216;RA&#8217;,&#8217;DEC&#8217;] with strings representing equatorial
coordinates, e.g. [&#8216;01:34:32.8&#8217;, &#8216;+30:47:00.6&#8217;].</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>or:</dt>
<dd><ul class="first last simple">
<li>[RA, DEC] where RA and DEC being the coordinates in Grad.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p><strong>apertureSize: float [arcsec]</strong> :</p>
<blockquote>
<div><p>The diameter of the aperture to be applied.</p>
</div></blockquote>
<p><strong>backgroundSize: float [arcsec]</strong> :</p>
<blockquote>
<div><p>The Size of the Anulli in which the background is
to be estimated. The number to be given here
correspond to the diameter of the circle in [arcsec ] descibing
the outer border of the annuli, measured from
the position given in position. Thus, the background
is measurd in the ring described by apertureSize and
backgroundSize. Default is 0 and thus <strong>no background substaction</strong>
is applied.</p>
</div></blockquote>
<p><strong>output: True or False</strong> :</p>
<blockquote>
<div><p>If True the function reports the calculated values during 
execution.</p>
</div></blockquote>
<p><strong>annotion: logical</strong> :</p>
<blockquote>
<div><p>If True an kvis annotation file <tt class="docutils literal"><span class="pre">&quot;apertures.ann&quot;</span></tt> containing the 
aperture used to integrate the flux. Default is False, i.e. not to 
create the aperture.</p>
</div></blockquote>
<p><strong>newAnnotation: logical</strong> :</p>
<blockquote>
<div><p>If True <tt class="docutils literal"><span class="pre">&quot;apertures.ann&quot;</span></tt> is overwritten.
If False an old <tt class="docutils literal"><span class="pre">&quot;apertures.ann&quot;</span></tt> is used to append the new 
apertures. If it not exists a new one is created. 
The latter is the default.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>List:  [Sum, Mean, Number of pixels]</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.sky2pix">
<tt class="descname">sky2pix</tt><big>(</big><em>coordinate</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.sky2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Pixel corresponding to a given coordinate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coordinate: list</strong> :</p>
<blockquote>
<div><p>Either [&#8216;RA&#8217;,&#8217;DEC&#8217;] in equatorial coordinates or [RA, DEC] in GRAD.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>pixel: List</strong> :</p>
<blockquote class="last">
<div><p>[x, y]; the pixel coordinates of the map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>newRes</em>, <em>oldRes=None</em>, <em>scale='0.0'</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Still in Development. Maybe Never finished. 
<strong>Do Not Use</strong></p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.strip">
<tt class="descname">strip</tt><big>(</big><em>coords</em>, <em>radial=None</em>, <em>centerCoord=None</em>, <em>distance=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a linear cut trough a map between two coordinates.</p>
<p>Distance in kpc.</p>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.toGildas">
<tt class="descname">toGildas</tt><big>(</big><em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.toGildas" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the current map to the Gildas Format.</p>
<p>The function takes changes to the map_name variables 
made outside of functions into account via
<a class="reference internal" href="#astrolyze.mapclass.mapClassMain.Map.returnName" title="astrolyze.mapclass.mapClassMain.Map.returnName"><tt class="xref py py-func docutils literal"><span class="pre">astrolyze.mapclass.mapClassMain.Map.returnName()</span></tt></a> into account.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>prefix: string or None</strong> :</p>
<blockquote class="last">
<div><p>Path to location where the new gildas file will be stored.
The default is None which defaults to the current self.prefix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>To continue working with the gildas map use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">toGildas</span><span class="p">()</span>
</pre></div>
</div>
<p>To only store the current map in the gildas format and go on
working with the fits file use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">toGildas</span><span class="p">()</span>
</pre></div>
</div>
<p>Here map is an Instance of the FitsMap class.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.toMiriad">
<tt class="descname">toMiriad</tt><big>(</big><em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.toMiriad" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the current map to the Miriad Format.</p>
<p>The function takes changes to the map_name variables 
made outside of functions into account via
<tt class="xref py py-func docutils literal"><span class="pre">mapclass.mapClassMain.Map.returnName()</span></tt> into account.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>prefix: string or None</strong> :</p>
<blockquote class="last">
<div><p>Path to location where the new gildas file will be stored.
The default is None which defaults to the current self.prefix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This function works like 
<tt class="xref py py-func docutils literal"><span class="pre">mapclass.mapClassFits.FitsMap.toGildas()</span></tt> and the same
Examples apply.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassFits.FitsMap.update_file">
<tt class="descname">update_file</tt><big>(</big><em>backup=False</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassFits.FitsMap.update_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Writing changes to the self.data and/or self.header to the current
file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>backup: True or False</strong> :</p>
<blockquote>
<div><p>If True a copy of the original file is created having the extension 
<tt class="docutils literal"><span class="pre">&quot;_old&quot;</span></tt> after the file endind, i.e. some_name.fits -&gt; some_name.
fits_old.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>FitsMap: Instance</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If all variables that define the map name () are unchanged the current
file is overwritten else</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapclassgildas">
<h2>MapClassGildas<a class="headerlink" href="#mapclassgildas" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap">
<em class="property">class </em><tt class="descclassname">astrolyze.mapclass.mapClassGildas.</tt><tt class="descname">GildasMap</tt><big>(</big><em>mapName</em>, <em>nameConvention=True</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapping GILDAS functions to use them inline with Python.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.goRot">
<tt class="descname">goRot</tt><big>(</big><em>angle</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.goRot" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to the GREG go rot command, which rotates maps around their
central coordinate stored in the header.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>angle: float [deg]</strong> :</p>
<blockquote>
<div><p>Rotation angle.</p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote>
<div><p>The path where the output is to be stored if different
from the current prefix of the map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>GildasMap Object: Instance for the reprojected map.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">goRot</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
</pre></div>
</div>
<p>To change the central coordinate first use
<tt class="xref py py-func docutils literal"><span class="pre">mapclass.mapClassGildas.GildasMap.reproject()</span></tt> e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;new_RA_string&#39;</span><span class="p">,</span><span class="s">&#39;new_DEC_string&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">goRot</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.lmv">
<tt class="descname">lmv</tt><big>(</big><em>fileout=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.lmv" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to the lmv command of Class to extract spectra from a
spectral cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>fileout: string</strong> :</p>
<blockquote>
<div><p>The name of the class file to write the spectra to. Defaults to
<tt class="docutils literal"><span class="pre">&quot;temp.30m&quot;</span></tt>.</p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote class="last">
<div><p>The path were the class file will be stores. Defaults to
the current path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.mask">
<tt class="descname">mask</tt><big>(</big><em>polygon</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to the GREG task mask:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>polygon: string</strong> :</p>
<blockquote>
<div><p>path to a GILDAS polygon file with ending <tt class="docutils literal"><span class="pre">&quot;.pol&quot;</span></tt></p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote>
<div><p>The path where the output is to be stored if different
from the current prefix of the map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>mapObject: The masked map object.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="s">&#39;poly/sourceA.pol&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.moments">
<tt class="descname">moments</tt><big>(</big><em>velo_range=[0, 0], threshold=0, smooth='NO', prefix=None, comment=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the GREG task moments creating the first three moments
of the map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>velo_range: list</strong> :</p>
<blockquote>
<div><p>Velocity range for the integration</p>
</div></blockquote>
<p><strong>threshold: float</strong> :</p>
<blockquote>
<div><p>Value under which pixels are blanked</p>
</div></blockquote>
<p><strong>smooth: string</strong> :</p>
<blockquote>
<div><p>One of Either <tt class="docutils literal"><span class="pre">&quot;NO&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;YES&quot;</span></tt>. Steers if the map is smoothed
before applying the cut threshold. Defaults to <tt class="docutils literal"><span class="pre">'NO'</span></tt></p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote>
<div><p>The path where the output is to be stored if different
from the current prefix of the map.</p>
</div></blockquote>
<p><strong>comment: string</strong> :</p>
<blockquote>
<div><p>Optional comments to be added to the new map name.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>None</strong> : At the moment nothing.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Include return of a mapObject.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.regrid_to_arcsec">
<tt class="descname">regrid_to_arcsec</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.regrid_to_arcsec" title="Permalink to this definition">¶</a></dt>
<dd><p>Regrids the pixel size of the map to a multiple of arcseconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>value: float</strong> :</p>
<blockquote class="last">
<div><p>The new pixel size in arcsecs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Old function no guarantee of functionality. Test or remove!</p>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.reproject">
<tt class="descname">reproject</tt><big>(</big><em>template=None</em>, <em>coord=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.reproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the GREG task reproject. Either use template <em>or</em> coord.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>template: string</strong> :</p>
<blockquote>
<div><p>Full path to a map in GDF Format whose central
coordinate and pixel size will serve as a template.</p>
</div></blockquote>
<p><strong>coord: list</strong> :</p>
<blockquote>
<div><p>List of coordinate strings in RA DEC (J2000) that
will become the new centre of the map.</p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote>
<div><p>The path where the output is to be stored if different
from the current prefix of the map. If None the current
self.prefix of the GildasMap instance is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>GildasMap Object: Instance for the reprojected map.</strong> :</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>SystemExit</strong> :</p>
<blockquote class="last">
<div><p>If both <strong>template</strong> and <strong>coord</strong> are not <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>For more information on the Gildas task see:
.. [R1] www.iram.fr/GILDAS/</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">coord</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;1:34:32.8&#39;</span><span class="p">,</span> <span class="s">&#39;30:47:00.6&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">template</span> <span class="o">=</span> <span class="s">&#39;M33_SPIRE_250_JyB_18.1.gdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.smooth">
<tt class="descname">smooth</tt><big>(</big><em>new_resolution</em>, <em>old_resolution=None</em>, <em>prefix=None</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to the GREG task gauss_smooth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>new_resolution: float or list</strong> :</p>
<blockquote>
<div><p>The resulting resolution after the smoothing.
It can be:</p>
<blockquote>
<div><ol class="arabic simple">
<li>a float: i.e. the final major and minor beamsize.
The position angle will default to 0.</li>
<li>a list with two floats: [major_axis, minor_axis]. The
position angle defaults to 0.</li>
<li>a list with three floats: [major_axis, minor_axis,
position_angle].</li>
</ol>
</div></blockquote>
</div></blockquote>
<p><strong>old_resolution: float or list</strong> :</p>
<blockquote>
<div><p>Same format as new_resolution. Defaults to self.resolution of the
map instance.</p>
</div></blockquote>
<p><strong>prefix: string</strong> :</p>
<blockquote class="last">
<div><p>The path where the output is to be stored if different
from the current prefix of the map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The gauss_smooth Task from GILDAS only gives correct output
units when the map is on a temperature or &#8220;per pixel&#8221; scale.
<strong>Maps in Jy/Beam won&#8217;t be in Jy/Beam after smoothing.</strong></p>
</div>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.toFits">
<tt class="descname">toFits</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.toFits" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the actual map to a Fits map.</p>
<p class="rubric">Examples</p>
<p>With:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="n">gildasMap</span><span class="p">(</span><span class="s">&#39;M33_MIPS_24mum_JyB_5.gdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">toFits</span><span class="p">()</span>
</pre></div>
</div>
<p>it is possible to continue working with the fits map, using the
<tt class="xref py py-class docutils literal"><span class="pre">mapclass.mapClassFits.FitsMap</span></tt> class.</p>
</dd></dl>

<dl class="method">
<dt id="astrolyze.mapclass.mapClassGildas.GildasMap.toMiriad">
<tt class="descname">toMiriad</tt><big>(</big><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassGildas.GildasMap.toMiriad" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the actual map to a Miriad map.</p>
<p class="rubric">Examples</p>
<p>With:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="n">gildasMap</span><span class="p">(</span><span class="s">&#39;M33_MIPS_24mum_JyB_5.gdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">toMiriad</span><span class="p">()</span>
</pre></div>
</div>
<p>it is possible to continue working with the Miriad map, using
<tt class="xref py py-class docutils literal"><span class="pre">mapclass.mapClassMiriad.MiriadMap</span></tt> class.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapclassmiriad">
<h2>MapClassMiriad<a class="headerlink" href="#mapclassmiriad" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astrolyze.mapclass.mapClassMiriad.MiriadMap">
<em class="property">class </em><tt class="descclassname">astrolyze.mapclass.mapClassMiriad.</tt><tt class="descname">MiriadMap</tt><big>(</big><em>mapName</em>, <em>nameConvention=True</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMiriad.MiriadMap" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<dl class="method">
<dt id="astrolyze.mapclass.mapClassMiriad.MiriadMap.moment">
<tt class="descname">moment</tt><big>(</big><em>iN=''</em>, <em>region=''</em>, <em>out=''</em>, <em>mom='0'</em>, <em>axis=''</em>, <em>clip=''</em>, <em>rngmsk=''</em>, <em>raw=''</em><big>)</big><a class="headerlink" href="#astrolyze.mapclass.mapClassMiriad.MiriadMap.moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap around MIRIADs moment task. 
keywords are as in miriad. 
By default (-&gt; if you give no arguments to the function)
it creates the zeroth moment of the map</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-astrolyze.maptools">
<span id="maptools"></span><h1>MapTools<a class="headerlink" href="#module-astrolyze.maptools" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-astrolyze.maptools.mapTools"></span><dl class="function">
<dt id="astrolyze.maptools.mapTools.getCoordinates">
<tt class="descclassname">astrolyze.maptools.mapTools.</tt><tt class="descname">getCoordinates</tt><big>(</big><em>file</em><big>)</big><a class="headerlink" href="#astrolyze.maptools.mapTools.getCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of coordinates read from a file 
formated as follows:</p>
<blockquote>
<div>SourceName 1 RA1 DECN
SourceName 2 RA1 DECN
.
.
.
SourceNameN RA DEC</div></blockquote>
<p>Input:  file -&gt; i.e. File name 
Output: list with [[SourceName 1,...,SourceName N], [[RA 1,DEC 1],...,[RA N,DEC N]] ]</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.maptools.mapTools.unifyMaps">
<tt class="descclassname">astrolyze.maptools.mapTools.</tt><tt class="descname">unifyMaps</tt><big>(</big><em>list</em>, <em>tinMap</em>, <em>folder='reg'</em><big>)</big><a class="headerlink" href="#astrolyze.maptools.mapTools.unifyMaps" title="Permalink to this definition">¶</a></dt>
<dd><p>changes the dimensions and pixel sizes off all maps to that of a template map.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.maptools.mapTools.unifyResolution">
<tt class="descclassname">astrolyze.maptools.mapTools.</tt><tt class="descname">unifyResolution</tt><big>(</big><em>liste</em>, <em>resolution=False</em>, <em>folder='smooth'</em>, <em>scaling=''</em><big>)</big><a class="headerlink" href="#astrolyze.maptools.mapTools.unifyResolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Approved.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.maptools.mapTools.unifyUnits">
<tt class="descclassname">astrolyze.maptools.mapTools.</tt><tt class="descname">unifyUnits</tt><big>(</big><em>list</em>, <em>folder='units'</em><big>)</big><a class="headerlink" href="#astrolyze.maptools.mapTools.unifyUnits" title="Permalink to this definition">¶</a></dt>
<dd><p>NOT READY YET!</p>
</dd></dl>

</div>
<div class="section" id="module-astrolyze.sed">
<span id="seds"></span><h1>SEDs<a class="headerlink" href="#module-astrolyze.sed" title="Permalink to this headline">¶</a></h1>
<p>This module handles SED creation and display with 
MapClass.</p>
<div class="section" id="module-astrolyze.sed.sedCreation">
<span id="create-seds"></span><h2>Create SEDs<a class="headerlink" href="#module-astrolyze.sed.sedCreation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astrolyze.sed.sedCreation.getFluxes">
<tt class="descclassname">astrolyze.sed.sedCreation.</tt><tt class="descname">getFluxes</tt><big>(</big><em>name</em>, <em>tableFolder=''</em><big>)</big><a class="headerlink" href="#astrolyze.sed.sedCreation.getFluxes" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the data written by getSED and provides an array that is undestood 
by the fitting Algorithms astroFunctions.py</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.sed.sedCreation.getSED">
<tt class="descclassname">astrolyze.sed.sedCreation.</tt><tt class="descname">getSED</tt><big>(</big><em>fileList</em>, <em>coordList</em>, <em>tableFolder=''</em><big>)</big><a class="headerlink" href="#astrolyze.sed.sedCreation.getSED" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads SEDs from the fits maps given in the file fileList
which has to have the followin format:</p>
<p>frequency1 error1 pathname1
frequency2 error2 pathname2
.
.
.</p>
<p>The fluxes are read at the coordinates that are specified in the file 
coordList with the format</p>
<p>nameOfPosition1 RAcoordInDeg1 DECcoordinDeg1    
nameOfPosition2 RAcoordInDeg2 DECcoordinDeg2
.
.
THIS IS OUTDATED MOVE TO astrolyze.mapclass!!!!!!!
.</p>
</dd></dl>

</div>
<div class="section" id="module-astrolyze.sed.plotSEDs">
<span id="plot-seds"></span><h2>Plot SEDs<a class="headerlink" href="#module-astrolyze.sed.plotSEDs" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astrolyze.sed.plotSEDs.create_figure">
<tt class="descclassname">astrolyze.sed.plotSEDs.</tt><tt class="descname">create_figure</tt><big>(</big><em>pList, data, parted=[1], plotLegend='no', label=['Fluxes'], color=['black'], marker=['x'], markerSize=6, titleString='', xLabel='', yLabel='', textString1=None, nu_or_lambda='nu', fontdict=None, printFitResult=True, fitResultLoc=[50, 10], lineWidth=0.5, kappa='easy', chisq='', xRange='normal', plotXlabel=None, plotYlabel=None, noXtics=False, noYtics=False, lineColor='black', ylim=[0.001, 30.0], xlim=[500, 20000]</em><big>)</big><a class="headerlink" href="#astrolyze.sed.plotSEDs.create_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the total SED of M33. Resamples the older gildas output. 
input: 
pList: Multi-Component GreyBody parameters. pList = [[t1,t2,t3,...],
[N1,N2,N3,...],[beta]]</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.sed.plotSEDs.plot_sed">
<tt class="descclassname">astrolyze.sed.plotSEDs.</tt><tt class="descname">plot_sed</tt><big>(</big><em>p2</em>, <em>nu_or_lambda='nu'</em>, <em>color='black'</em>, <em>kappa='easy'</em>, <em>linewidth=0.5</em>, <em>xRange='normal'</em><big>)</big><a class="headerlink" href="#astrolyze.sed.plotSEDs.plot_sed" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a multi component greybody model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p2</strong> &#8211; formatted: p2 = [[t1,t2,t3,...], [N1,N2,N3,...], [beta]]</li>
<li><strong>nu_or_lambda</strong> &#8211; plot against frequency <tt class="docutils literal"><span class="pre">'nu'</span></tt> or wavelenght 
<tt class="docutils literal"><span class="pre">'lambda'</span></tt></li>
<li><strong>kappa</strong> &#8211; The kappa to use. <tt class="docutils literal"><span class="pre">'easy'</span></tt> or <tt class="docutils literal"><span class="pre">'Kruegel'</span></tt>. Please refer
to <tt class="xref py py-func docutils literal"><span class="pre">functions.astroFunctions.greyBody()</span></tt> for more information.</li>
<li><strong>xRange</strong> &#8211; PLEASE ADD DESCRIPTION</li>
<li><strong>linewidth</strong> &#8211; The linewidth of the plotted lines. Default to 0.5.</li>
<li><strong>linewidth</strong> &#8211; float</li>
<li><strong>color</strong> (<em>matplotlib conform color.</em>) &#8211; the color of the plotted lines. Default to <tt class="docutils literal"><span class="pre">'black'</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-astrolyze.functions">
<span id="functions"></span><h1>Functions<a class="headerlink" href="#module-astrolyze.functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-astrolyze.functions.astroFunctions">
<span id="astrofunctions"></span><h2>astroFunctions<a class="headerlink" href="#module-astrolyze.functions.astroFunctions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astrolyze.functions.astroFunctions.LTIR">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">LTIR</tt><big>(</big><em>p2</em>, <em>kappa='Kruegel'</em>, <em>xmin=3.0</em>, <em>xmax=1100.0</em>, <em>beamConv=True</em>, <em>distance=847000.0</em>, <em>unit='Lsun'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.LTIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration of a multicomponent greybody model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p2: list</strong> :</p>
<blockquote>
<div><p>The parameters defining the multi component greybody model.
Same format as p in 
<a class="reference internal" href="#astrolyze.functions.astroFunctions.multiComponent" title="astrolyze.functions.astroFunctions.multiComponent"><tt class="xref py py-func docutils literal"><span class="pre">astrolyze.functions.astroFunctions.multiComponent()</span></tt></a></p>
</div></blockquote>
<p><strong>kappa: string</strong> :</p>
<blockquote>
<div><p>The dust extinction coefficient used to describe the 
greybodies. See
py:func:<cite>astrolyze.functions.astroFunctions.greyBody</cite></p>
</div></blockquote>
<p><strong>xmin, xmax: float</strong> :</p>
<blockquote>
<div><p>The integration range in units of micron. 
Defaults to 3 &#8211; 110 micron. The definition 
of LTIR from [DA]</p>
</div></blockquote>
<p><strong>beamConv: True or False</strong> :</p>
<blockquote>
<div><p>Not well coded. Hardcoded conversion between an 
28&#8221; and 40&#8221; beam. !! CHANGE !!</p>
</div></blockquote>
<p><strong>unit: string</strong> :</p>
<blockquote class="last">
<div><p>If <tt class="docutils literal"><span class="pre">'Lsun'</span></tt> the returned integrated flux is in units of 
solar luminosities (erg s^-1). For this a distance is needed. 
If <tt class="docutils literal"><span class="pre">'JyB'</span></tt> the units are Jy/beam; distance is not used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Needs some work to be generally usable. Right now
it is unfortunately written for one project only.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="da" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[DA]</a></td><td>Dale et al. 2001; ApJ; 549:215-227</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.Tex">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">Tex</tt><big>(</big><em>Tb</em>, <em>nu</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.Tex" title="Permalink to this definition">¶</a></dt>
<dd><p>calculation of the exitation Temperature of an optically thick 12CO line 
under the assumption of LTE</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.antiLine">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">antiLine</tt><big>(</big><em>p</em>, <em>y</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.antiLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Giving the x value of a line that corresponds to a given y value  of a 
line <cite>x = y/m - b</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p: list</strong> :</p>
<blockquote>
<div><p>Contains the slope and the y-axis intersection of the line [m, b].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>y: value of x corresponding to y.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.blackBody">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">blackBody</tt><big>(</big><em>x</em>, <em>T</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.blackBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the flux density of a black body at a 
temperature T and a wavelenght/frequency x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float or numpy array</strong> :</p>
<blockquote>
<div><p>wavelength [GHz] or frequency [micron]; 
specify type in nu_or_lambda</p>
</div></blockquote>
<p><strong>T: float [Kelvin]</strong> :</p>
<blockquote>
<div><p>Temperature of the Blackbody</p>
</div></blockquote>
<p><strong>nu_or_lambda: string</strong> :</p>
<blockquote>
<div><p>Specify whether x is a frequency <img class="math" src="_images/math/d6a7ccf879c4a4fe694033606332cb83806db296.png" alt="\nu"/> <tt class="docutils literal"><span class="pre">'nu'</span></tt> or
a wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> <tt class="docutils literal"><span class="pre">'lambda'</span></tt>; default is <tt class="docutils literal"><span class="pre">'nu'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>Flux density in Jansky: float [Jy]</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Extend the documentation!!</p>
<p class="rubric">Examples</p>
<p>The function works with linear numpy arrays. Thus the 
blackbody can be evaluated at many points at the same time.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">astrolyze.functions.astroFunctions</span> <span class="kn">as</span> <span class="nn">astFunc</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frequency_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1e3</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">0.5e3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mi">6000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blackbody</span> <span class="o">=</span> <span class="n">astFunc</span><span class="p">(</span><span class="n">frequency_range</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.calcColumnDensity">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">calcColumnDensity</tt><big>(</big><em>nu</em>, <em>Tmb</em>, <em>Tex</em>, <em>J</em>, <em>Z</em>, <em>mu</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.calcColumnDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Column densities of linear molecules</p>
<p>Units are all to be given in cgs
Z is the array of Partition function values for the corresponding 
Temperatures in T these are the log values of Z</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.errorFunction">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">errorFunction</tt><big>(</big><em>p</em>, <em>x</em>, <em>y</em>, <em>yErr</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.errorFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to be minimized by scipy.optimize.leastsq. 
It gives the difference between the measured fluxes, y, and the 
calculated fluxes for the parameters p of the SED at the given frequency x.</p>
<p>Inputs:
p:  startParameter as in greyBodyFit
x and y are the two rows, data[0] and data[1] of the data 
variable from greyBodyFit:</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.gauss1D">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">gauss1D</tt><big>(</big><em>x</em>, <em>fwhm</em>, <em>offset=0</em>, <em>amplitude=1</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.gauss1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulcates 1D Gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float or numpy.ndarray</strong> :</p>
<blockquote>
<div><p>the x-axis value/values where the gaussian is to be caluclated.</p>
</div></blockquote>
<p><strong>fwhm: float</strong> :</p>
<blockquote>
<div><p>The width of the gaussian.</p>
</div></blockquote>
<p><strong>offset:</strong> :</p>
<blockquote>
<div><p>The offset in x direction from 0. Default is 0.</p>
</div></blockquote>
<p><strong>amplitude:</strong> :</p>
<blockquote>
<div><p>The height of the gaussian. Default is 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>gauss: float or np.ndarray</strong> :</p>
<blockquote class="last">
<div><p>The y value for the specified gaussian distribution evaluated at x.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The function used to describe the gaussian is:</p>
<div class="math">
<p><img src="_images/math/a117eeb7e15c09fac721bc06005261c07d58c679.png" alt="f = \frac{1}{fwhm * sqrt(2 * \pi)} * e^{-1/2 (\frac{x-x0}{fwhm})^2}"/></p>
</div></dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.gauss2D">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">gauss2D</tt><big>(</big><em>x</em>, <em>y</em>, <em>major</em>, <em>minor</em>, <em>pa=0</em>, <em>xOffset=0</em>, <em>yOffset=0</em>, <em>amplitude=1</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.gauss2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calulcates a 2D Gaussian at position x y.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float or numpy.ndarray</strong> :</p>
<blockquote>
<div><p>the x-axis value/values where the gaussian is to be caluclated.</p>
</div></blockquote>
<p><strong>y: float or numpy.ndarray</strong> :</p>
<blockquote>
<div><p>the y-axis value/values where the gaussian is to be caluclated.</p>
</div></blockquote>
<p><strong>major, minor: float</strong> :</p>
<blockquote>
<div><p>The fwhm of the gaussian in x and y direction.</p>
</div></blockquote>
<p><strong>pa: float</strong> :</p>
<blockquote>
<div><p>The position angle of the gaussian in degrees. Default is 0.</p>
</div></blockquote>
<p><strong>xOffset, yOffset:</strong> :</p>
<blockquote>
<div><p>The offset in x and y direction from 0. Default is 0.</p>
</div></blockquote>
<p><strong>amplitude:</strong> :</p>
<blockquote>
<div><p>The height of the gaussian. Default is 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>gauss: float or np.ndarray</strong> :</p>
<blockquote class="last">
<div><p>The y value for the specified gaussian distribution evaluated at x.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The function used to describe the gaussian is :</p>
<div class="math">
<p><img src="_images/math/7bc964036a8d2c263e3e4e0409607a4731e0a46e.png" alt="f = (amplitude * exp (-1 (a*(x-xOffset)^2 + 2*b*(x-xOffset)*(y-yOffset)
    + c*(y-yOffset)^2)))"/></p>
</div><p>where:</p>
<div class="math">
<p><img src="_images/math/aeef519e41d529cc93203d38a00fdcf2f99941fd.png" alt="a = cos(pa)**2/(2*major**2) + sin(pa)**2/(2*minor**2) \\ 
b = (-1*sin(2*pa)/(4*major**2))+(sin(2*pa)/(4*minor**2)) \\ 
c = sin(pa)**2/(2*major**2) + cos(pa)**2/(2*minor**2) \\"/></p>
</div></dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.generateDataMC">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">generateDataMC</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.generateDataMC" title="Permalink to this definition">¶</a></dt>
<dd><p>MonteCarlo Simulation of a set of flux measurements, assuming that the
measurement data follows a gauss distribution.</p>
<p>This function makes use of the random.gauss() function to generate a 
data point from a gauss distribution, that has a mean equal to the Flux 
measurement and a standard deviation correponding to the error 
of the measurement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data: array</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>Same format as in greyBodyFit function:</dt>
<dd><p class="first last">data= [[x1, x2, x3, ...][y1, y2, y3, ...][z1, z2, z3, ...]]</p>
</dd>
</dl>
<p>with x = wavelenght/frequency, y = flux, z = error on flux.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>newData: array with the same format as data.</strong> :</p>
<blockquote class="last">
<div><p>The monte carlo simulated measurement.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">random.gauss</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">Monte</span></tt></p>
</div>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.generateLinearMCData">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">generateLinearMCData</tt><big>(</big><em>data</em>, <em>errors</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.generateLinearMCData" title="Permalink to this definition">¶</a></dt>
<dd><p>This function makes a MonteCarlo Simulation of a data Set of Flux 
measurements it uses the random.gauss() function to generate a data point 
from a gauss distribution, that has a mean equal to the Flux measurement 
and a standard deviation correponding to the error of the measurement. 
input:
data:   has tot be in the same format than, e.g. the greyBodyFit1 
function in this 
script. data= [[x1,x2,x3,...][y1,y2,y3,...][z1,z2,z3,...]]
with    x = wavelenght/frequency
y = flux 
z = error on flux
output:
Monte Carlo simulated data.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.greyBody">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">greyBody</tt><big>(</big><em>p</em>, <em>x</em>, <em>nu_or_lambda='nu'</em>, <em>kappa='Kruegel'</em>, <em>distance=840000.0</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.greyBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the flux density in Jansky of a greybody under assumption
of optically thin emission.</p>
<p>Please see Notes below for an detailed desciption assumptions and 
equations used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p: list</strong> :</p>
<blockquote>
<div><p>List of the parameters defining a greybody, being Temperature [K], 
column density or mass (dependend on the kappa used) and the greybody 
slope index beta, respectively (refer to notes for more information):</p>
<blockquote>
<div><p>p = [T, N, beta]</p>
</div></blockquote>
</div></blockquote>
<p><strong>x: float or numpy array</strong> :</p>
<blockquote>
<div><p>Wavelength [GHz] or frequency [micron]; 
specify type in nu_or_lambda</p>
</div></blockquote>
<p><strong>kappa: string</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>Chooses the dust extinction coeficient to use: </dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">&quot;easy&quot;</span></tt> -&gt; kappa = nu^beta; tau = N * kappa</li>
<li><tt class="docutils literal"><span class="pre">&quot;Kruegel&quot;</span></tt> -&gt; kappa = 0.04*(nu/250Ghz)^beta;
tau = M/D^2 * kappa</li>
</ul>
</dd>
</dl>
<p>Please refer to Notes below, for further explanation. `</p>
</div></blockquote>
<p><strong>distance: float</strong> :</p>
<blockquote>
<div><p>The distance to the source that is to be modeled if kappa 
<tt class="docutils literal"><span class="pre">&quot;Kruegel&quot;</span></tt> is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>nu_or_lambda: string</strong> :</p>
<blockquote class="last">
<div><p>Specify whether x is a frequency <img class="math" src="_images/math/d6a7ccf879c4a4fe694033606332cb83806db296.png" alt="\nu"/> <tt class="docutils literal"><span class="pre">'nu'</span></tt> or
a wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> <tt class="docutils literal"><span class="pre">'lambda'</span></tt>; default is <tt class="docutils literal"><span class="pre">'nu'</span></tt>.</p>
<p><strong>Don&#8217;t</strong> use <tt class="docutils literal"><span class="pre">'lambda'</span></tt> as this part of the script is not up-to-date
and does not treat the dust extinction coefficients correctly.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The general equation for a Greybody is:</p>
<div class="math">
<p><img src="_images/math/7e25348c253c9b60f9fd48ed53becbec26d86a17.png" alt="S(x, \tau) = (blackBody(x, T)) * [1 - e^\tau] \Omega"/></p>
</div><p>describing the flux coming from an solid angle
<img class="math" src="_images/math/9e2b196e9b7e57d1ec99f6534c581ea9759d2170.png" alt="\Omega"/> and where <img class="math" src="_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau"/> is:</p>
<div class="math">
<p><img src="_images/math/3978b4ff8f8024a353cd9022d28dc42411f2a725.png" alt="\tau_{\nu} = \frac{ \kappa_d(\nu) * M_{dust}}{D^2 \Omega} ."/></p>
</div><p>Here we assume optically thin emission and a source filling factor of 
unity. This simplyfies the equation of the greybody to:</p>
<div class="math">
<p><img src="_images/math/cee52ebd3b5c16d4fe7b0c475b594b0de43c5279.png" alt="S(x, \tau) = \tau * (blackBody(x, T))"/></p>
</div><p>This script supports two versions of the dust extinction coefficient.::
A simple version without a lot of physics put into, 
kappa = <tt class="docutils literal"><span class="pre">'easy'</span></tt> which defaults to the following greybody equation:</p>
<div class="math">
<p><img src="_images/math/1de3760f60388d8573bbb52041108d78bf3069f3.png" alt="S(x, \tau) = N * x^{\beta} * blackBody(x,T) ,"/></p>
</div><p>with N being a column density scaling factor.</p>
<p>The second version, kappa = <tt class="docutils literal"><span class="pre">'Kruegel'</span></tt> uses the dust extinction 
coefficient reported in [KS] which renders the used equation to:</p>
<div class="math">
<p><img src="_images/math/151e4c557468245830f9a8658212369322b1a219.png" alt="\kappa = 0.04 * (\frac{x\,[GHz]}{250\,GHz})^{\beta}

S_{\nu} = M[kg] / D^2[m^2] * \kappa * blackBody(x,T) ."/></p>
</div><p class="rubric">References</p>
<table class="docutils citation" frame="void" id="ks" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[KS]</a></td><td>Kruegel, E. &amp; Siebenmorgen, R. 1994, A&amp;A, 288, 929</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.greyBodyFit">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">greyBodyFit</tt><big>(</big><em>data</em>, <em>startParameter</em>, <em>nu_or_lambda='nu'</em>, <em>fit_beta=False</em>, <em>fix_temperature=False</em>, <em>rawChiSq=None</em>, <em>kappa='Kruegel'</em>, <em>residuals='False'</em>, <em>iterations=1000000000.0</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.greyBodyFit" title="Permalink to this definition">¶</a></dt>
<dd><p>This function fits a multi component greybody model to an 
observed SED for the optical thin case.</p>
<p>This function has four free parameters. In order to work properly 
it needs also at least four data points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data: array</strong> :</p>
<blockquote>
<div><p>The obseved data. Array of shape(3, x) first row has to be the X values
(Frequency in [GHz]) of the measurements, second row the Y values 
(Flux [Jy]), and the third row  the Z values the errors on the 
fluxes i.e.:</p>
<blockquote>
<div><p>data = array([[X1, X2, X3, ...], [Y1, Y2, Y3,...], [Z1, Z2, 
Z3, ...]])</p>
</div></blockquote>
</div></blockquote>
<p><strong>startParameter: array</strong> :</p>
<blockquote>
<div><p>Array of a first guess of the parameters of the greybody components. 
The number of components is arbitrary</p>
<blockquote>
<div><p>startParameter = [[T1, T2, T3,...], [N1, N2, N3, ...], beta]</p>
</div></blockquote>
</div></blockquote>
<p><strong>fit_beta: True or False</strong> :</p>
<blockquote>
<div><p>If True Beta is allowed to vary. Default is False.</p>
</div></blockquote>
<p><strong>fix_temperature: True or False</strong> :</p>
<blockquote>
<div><p>If True the Temperature is fixed allowed to vary.</p>
</div></blockquote>
<p><strong>rawChiSq:</strong> :</p>
<blockquote>
<div><p>if None the function gives the reduced chisq Value. If True the 
function gives chisq without dividing it by the dof</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>p2: list</strong> :</p>
<blockquote>
<div><p>The final greybody parameters that reduce the least squares for the 
given dataset.</p>
</div></blockquote>
<p><strong>chisq/rawChiSq:</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>chisq is reduced chisq with degrees of freedom: </dt>
<dd><p class="first last">dof= #dataPoints-#freeFitParameters-1</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>nu_or_lambda: string</strong> :</p>
<blockquote class="last">
<div><p>Specify whether x is a frequency <img class="math" src="_images/math/d6a7ccf879c4a4fe694033606332cb83806db296.png" alt="\nu"/> <tt class="docutils literal"><span class="pre">'nu'</span></tt> or
a wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> <tt class="docutils literal"><span class="pre">'lambda'</span></tt>; default is <tt class="docutils literal"><span class="pre">'nu'</span></tt>.::
<strong>Don&#8217;t</strong> use <tt class="docutils literal"><span class="pre">'lambda'</span></tt> as this part of the 
<a class="reference internal" href="#astrolyze.functions.astroFunctions.greyBody" title="astrolyze.functions.astroFunctions.greyBody"><tt class="xref py py-func docutils literal"><span class="pre">greyBody()</span></tt></a> is not up-to-date.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">scipy.optimize.leastsq</span></tt></dt>
<dd>This function is used to perform the least squares fit.</dd>
</dl>
<p class="last"><a class="reference internal" href="#astrolyze.functions.astroFunctions.multiComponent" title="astrolyze.functions.astroFunctions.multiComponent"><tt class="xref py py-obj docutils literal"><span class="pre">multiComponent</span></tt></a>, <a class="reference internal" href="#astrolyze.functions.astroFunctions.greyBody" title="astrolyze.functions.astroFunctions.greyBody"><tt class="xref py py-obj docutils literal"><span class="pre">greyBody</span></tt></a>, <a class="reference internal" href="#astrolyze.functions.astroFunctions.blackBody" title="astrolyze.functions.astroFunctions.blackBody"><tt class="xref py py-obj docutils literal"><span class="pre">blackBody</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>A one component fit has four free parameters if beta is allowed to vary
or three if beta is fixed (one more than parameters to fit). 
Each additional component adds two more free paramters to fit. 
Assure that:</p>
<blockquote>
<div>number of data points &gt; number of free parameters.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.line">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">line</tt><big>(</big><em>p</em>, <em>x</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluation of a line <cite>y = m*x + b</cite> equation at point x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p: list</strong> :</p>
<blockquote>
<div><p>Contains the slope and the y-axis intersection of the line [m, b].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>y: value of y corresponding to x.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.lineErrXY">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">lineErrXY</tt><big>(</big><em>p</em>, <em>x</em>, <em>y</em>, <em>xErr</em>, <em>yErr</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.lineErrXY" title="Permalink to this definition">¶</a></dt>
<dd><p>Error function, i.e. residual from the measured value, which has to be 
minimised in the least square fit taking X and Y Error into account.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.lineErrY">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">lineErrY</tt><big>(</big><em>p</em>, <em>x</em>, <em>y</em>, <em>yErr</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.lineErrY" title="Permalink to this definition">¶</a></dt>
<dd><p>Error function, i.e. residual from the measured value, which has to be  
minimised in the least square fit taking only y error into account.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.lineFit">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">lineFit</tt><big>(</big><em>p</em>, <em>x</em>, <em>y</em>, <em>xerr</em>, <em>yerr</em>, <em>XY_or_Y='XY'</em>, <em>iterations=10000</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.lineFit" title="Permalink to this definition">¶</a></dt>
<dd><p>XY_or_Y = only Y errors or also X errors, &#8216;XY&#8217; or &#8216;Y&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.linearLeastSqFit">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">linearLeastSqFit</tt><big>(</big><em>x</em>, <em>y</em>, <em>xerr</em>, <em>yerr</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.linearLeastSqFit" title="Permalink to this definition">¶</a></dt>
<dd><p>This fit is a analytical solution following chaper 8 from 
&#8220;An introduction to the study of uncertainties in physicak measurement&#8221;
by John R. Taylor</p>
<p>without errors the following holds for</p>
<p>y=A+BX</p>
<p>A = sum(x^2)*sum(y)-sum(x)*sum(x*y)/Delta
B = N*sum(x*y)-sum(x)*sum(y)/Delta
Delta = N*sum(x^2)-(sum(x))**2</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.monteCarloCheckData">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">monteCarloCheckData</tt><big>(</big><em>p</em>, <em>data</em>, <em>iterations</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.monteCarloCheckData" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to evaluate the errors in the parameters fitted with
the greyBodyFit function.</p>
<p>It uses Monte Carlo Simulated data (from generateDataMC) and performs a
fit to this new data giving back the results of the fit parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p: list</strong> :</p>
<blockquote>
<div><p>The parameters defining the multi component greybody model to be
fitted. Same format as p in 
<a class="reference internal" href="#astrolyze.functions.astroFunctions.multiComponent" title="astrolyze.functions.astroFunctions.multiComponent"><tt class="xref py py-func docutils literal"><span class="pre">multiComponent()</span></tt></a></p>
</div></blockquote>
<p><strong>data: array</strong> :</p>
<blockquote>
<div><p>The actual measured data of the SED, same format as for 
<tt class="xref py py-func docutils literal"><span class="pre">greyBodyFitFunction()</span></tt></p>
</div></blockquote>
<p><strong>iterations: int</strong> :</p>
<blockquote>
<div><p>Number of times new data is generated and fitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>string:</strong> :</p>
<blockquote>
<div><p>Containing the mean, standard deviation of the fit parameters, ready
to print out.</p>
</div></blockquote>
<p><strong>betaTlist: List of all fit results. Name misleading since it may not</strong> :</p>
<blockquote class="last">
<div><p>include the beta.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.monteCarloCheckLinearData">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">monteCarloCheckLinearData</tt><big>(</big><em>p</em>, <em>x</em>, <em>y</em>, <em>xerr</em>, <em>yerr</em>, <em>iterations</em>, <em>fitIterations=1000000000.0</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.monteCarloCheckLinearData" title="Permalink to this definition">¶</a></dt>
<dd><p>Gererate an estimate of the errors of the fitted parameters determined by
the <a class="reference internal" href="#astrolyze.functions.astroFunctions.greyBodyFit" title="astrolyze.functions.astroFunctions.greyBodyFit"><tt class="xref py py-func docutils literal"><span class="pre">greyBodyFit()</span></tt></a> function.</p>
<p>Using Monte Carlo Simulated SED data (<a class="reference internal" href="#astrolyze.functions.astroFunctions.generateDataMC" title="astrolyze.functions.astroFunctions.generateDataMC"><tt class="xref py py-func docutils literal"><span class="pre">generateDataMC()</span></tt></a>) 
this function fits an SED using <a class="reference internal" href="#astrolyze.functions.astroFunctions.greyBodyFit" title="astrolyze.functions.astroFunctions.greyBodyFit"><tt class="xref py py-func docutils literal"><span class="pre">greyBodyFit()</span></tt></a> 
and giving back the results of the fit parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>p: list</strong> :</p>
<blockquote>
<div><p>parameter List with start parameters</p>
</div></blockquote>
<p><strong>data: array</strong> :</p>
<blockquote>
<div><p>input data, same format as for <tt class="xref py py-func docutils literal"><span class="pre">greyBodyFitFunction()</span></tt></p>
</div></blockquote>
<p><strong>iterations: integer</strong> :</p>
<blockquote>
<div><p>Number of dice throws</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>string:</strong> :</p>
<blockquote>
<div><p>containing the mean, standard deviation of the fit parameters</p>
</div></blockquote>
<p><strong>Fitlist: Name misleading since it may not include the beta, list of all</strong> :</p>
<p class="last"><strong>fit results</strong> :</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">grebodyFit</span></tt>, <a class="reference internal" href="#astrolyze.functions.astroFunctions.generateDataMC" title="astrolyze.functions.astroFunctions.generateDataMC"><tt class="xref py py-obj docutils literal"><span class="pre">generateDataMC</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Documentation of Returns not complete please extend.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.astroFunctions.multiComponent">
<tt class="descclassname">astrolyze.functions.astroFunctions.</tt><tt class="descname">multiComponent</tt><big>(</big><em>pMulti</em>, <em>x</em>, <em>nu_or_lambda='nu'</em>, <em>kappa='Kruegel'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.astroFunctions.multiComponent" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines multiple greyBody functions and returns the flux density in Jansky
for the input frequency/wavelenght.</p>
<dl class="docutils">
<dt>pMulti: nested lists </dt>
<dd>Similar to p from 
<tt class="xref py py-func docutils literal"><span class="pre">functions.astroFunctions.greyBody()</span></tt> but the three entries 
are lists, i.e.:: 
pMulti = [[T1, T2, T3, ...Tn], [N1, N2, N3,...Nn], [beta]]</dd>
<dt>x: float or numpy array</dt>
<dd>frequency [micron] (or wavelenght <strong>Not maintained</strong>, specify type in   
nu_or_lambda)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>sum(snu): float</strong> :</p>
<blockquote>
<div><p>All dust components summed.</p>
</div></blockquote>
<p><strong>snu:</strong> :</p>
<blockquote class="last">
<div><p>A list with the fluxes of the individual components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#astrolyze.functions.astroFunctions.greyBody" title="astrolyze.functions.astroFunctions.greyBody"><tt class="xref py py-obj docutils literal"><span class="pre">greyBody</span></tt></a></dt>
<dd>The greybody function.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Only one common beta for all components can be used. May be expanded to 
mutliple betas if needed.</p>
</dd></dl>

</div>
<div class="section" id="units">
<h2>units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">astrolyze.functions.constants</span> <span class="kn">as</span> <span class="nn">const</span>
<span class="c"># constant conversion factors</span>
<span class="c">#==============&gt; Approved !!! &lt;==========================</span>
<span class="n">WattToErgs</span>    <span class="o">=</span> <span class="mf">1e7</span>   <span class="c"># 1W = 1e7 erg/s</span>
<span class="n">ErgsToWatt</span>    <span class="o">=</span> <span class="mf">1e-7</span>  <span class="c"># 1W = 1e-7 erg/s</span>
<span class="n">JanskyToWatt</span>  <span class="o">=</span> <span class="mf">1e-26</span> <span class="c"># 1Jy = 1e-26 W/m2/Hz </span>
<span class="n">WattToJansky</span>  <span class="o">=</span> <span class="mf">1e26</span>  <span class="c"># 1W  = 1 Jy * m2 * Hz</span>
<span class="n">ErgsToJansky_cm</span>  <span class="o">=</span> <span class="mf">1e23</span>  <span class="c"># 1erg/s =  1e23 Jy * cm2 * Hz * s </span>
<span class="n">JanskyToErgs_cm</span>  <span class="o">=</span> <span class="mf">1e-23</span> <span class="c"># 1 Jy = 1e-23 erg/s/cm2/Hz</span>
<span class="n">ErgsToJansky_m</span>  <span class="o">=</span> <span class="mf">1e19</span> <span class="c"># 1 Jy = 1e-23 erg/s/cm2/Hz</span>
<span class="n">JanskyToErgs_m</span>  <span class="o">=</span> <span class="mf">1e-19</span> <span class="c"># 1 Jy = 1e-23 erg/s/cm2/Hz</span>

<span class="k">def</span> <span class="nf">kelvin_to_jansky</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">nu_or_lambda</span><span class="o">=</span><span class="s">&#39;nu&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conversion from K.km/s (Tmb) and Jy/beam.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x: float</span>
<span class="sd">        wavelenght/frequency [GHZ],</span>
<span class="sd">    major: float</span>
<span class="sd">        Major Axis Beam (arcsec),</span>
<span class="sd">    minor: float</span>
<span class="sd">        Minor Axis Beam(arcsec),</span>
<span class="sd">    nu_or_lambda: string</span>
<span class="sd">         Choose type of x: frequency = ``&#39;nu&#39;`` or wavelenght = ``&#39;lambda&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    This function has been compared with the Time estimator from the</span>
<span class="sd">    [GILDAS] package ASTRO and yields the same conversion factors.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [GILDAS] www.iram.fr/IRAMFR/GILDAS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">fcon</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.359918e7</span> <span class="o">*</span> <span class="n">wavelengths</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">major</span> <span class="o">/</span> <span class="n">minor</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;nu&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">fcon</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.222233e6</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">major</span> <span class="o">/</span> <span class="n">minor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fcon</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">jansky_to_kelvin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">nu_or_lambda</span><span class="o">=</span><span class="s">&#39;nu&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conversion from Jy/beam to K.km/s (Tmb).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x: float</span>
<span class="sd">        wavelenght/frequency [GHZ],</span>
<span class="sd">    major: float</span>
<span class="sd">        Major Axis Beam (arcsec).</span>
<span class="sd">    minor: float</span>
<span class="sd">        Minor Axis Beam(arcsec).</span>
<span class="sd">    nu_or_lambda: string</span>
<span class="sd">         Choose type of x: frequency = ``&#39;nu&#39;`` or wavelenght = ``&#39;lambda&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Approved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">fcon</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">1.359918e7</span> <span class="o">*</span> <span class="n">wavelengths</span> <span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">major</span> <span class="o">/</span> <span class="n">minor</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;nu&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">fcon</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">Maj</span><span class="p">,</span> <span class="n">Min</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">1.222233e6</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">major</span> <span class="o">/</span> <span class="n">minor</span>
    <span class="k">return</span> <span class="n">fcon</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">WmToKkms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sterad</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ToKKms</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">m2_or_cm2</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">,</span> 
             <span class="n">nu_or_lambda</span><span class="o">=</span><span class="s">&#39;nu&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Conversion between W/m2 and K km/s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    x: float</span>
<span class="sd">        wavelenght/frequency [GHZ].</span>
<span class="sd">    resolution: float</span>
<span class="sd">    ToKKms: True or False</span>
<span class="sd">        Direction of the conversion.</span>
<span class="sd">    sterad: True or False</span>
<span class="sd">        If False convert from per beam to per sterad.</span>
<span class="sd">    m2_or_cm2: string</span>
<span class="sd">        Choose if conversion to/from W m-2 oder W cm-2. ``&#39;m2&#39;`` or ``&#39;cm2&#39;``.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># To W=Joule/s =&gt; Joule = 1e7 erg</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">m2_or_cm2</span> <span class="o">==</span> <span class="s">&#39;cm2&#39;</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="mf">1e7</span> <span class="c">#erg/m2/s</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">/</span> <span class="mf">1e4</span> <span class="c"># erg/cm2/s</span>
    <span class="k">if</span> <span class="n">sterad</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">beamsr</span> <span class="o">=</span> <span class="mf">1.133</span> <span class="o">*</span> <span class="p">(</span><span class="n">resolution</span> <span class="o">*</span> <span class="mf">4.848e-6</span><span class="p">)</span> <span class="o">**</span><span class="mi">2</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">/</span><span class="n">beamsr</span> <span class="c"># erg/cm2/s/sr</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">x</span>
    <span class="c"># Umrechung zwischen ergs/s/cm2/sr = 2 k(CGS) nu^3/c(sm)^3 K km/s </span>
    <span class="c"># =&gt; to make the units fit we have to multiply by 1*km in cm -&gt; 1e5</span>
    <span class="n">cInCm</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">1e2</span>
    <span class="n">kmInCm</span> <span class="o">=</span> <span class="mf">1e5</span>
    <span class="c"># converts from K - &gt; ergs</span>
    <span class="n">conversionFactor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k_CGS</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">kmInCm</span> <span class="o">/</span> <span class="p">(</span><span class="n">cInCm</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">/</span> <span class="n">conversionFactor</span>
    <span class="k">if</span> <span class="n">ToKKms</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">factor</span>
    <span class="k">if</span> <span class="n">ToKKms</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">factor</span>

<span class="k">def</span> <span class="nf">ergToKkms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">toErg</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nu_or_lambda</span><span class="o">=</span><span class="s">&#39;nu&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Conversion between ergs/cm2/s/sr and K km/s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    x: float</span>
<span class="sd">        wavelenght/frequency [GHZ],</span>
<span class="sd">    toErg: True or False</span>
<span class="sd">        True converts the other direction, i.e. from K km/s to ergs/cm2/s/sr.</span>
<span class="sd">    nu_or_lambda: string</span>
<span class="sd">         Choose type of x: frequency = ``&#39;nu&#39;`` or wavelenght = ``&#39;lambda&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Approved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># To W=Joule/s =&gt; Joule = 1e7 erg</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c">#print value</span>
    <span class="k">if</span> <span class="n">nu_or_lambda</span> <span class="o">==</span> <span class="s">&#39;lambda&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">299792458</span> <span class="o">/</span> <span class="n">x</span>
    <span class="c"># Conversion between erg/s/cm2/sr = 2k(CGS) nu^3/c(cm)^3 K km/s </span>
    <span class="c"># k(CGS) is Boltzsmanns constant in units of the CGS, nu the frequency of </span>
    <span class="c"># the measusrement</span>
    <span class="c"># c(cm) is the speed of light in cm. </span>
    <span class="c"># =&gt; to make the units fit we have to multiply by 1*km in cm -&gt; 1e5</span>
    <span class="n">cInCm</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">1e2</span>
    <span class="n">kmInCm</span> <span class="o">=</span> <span class="mf">1e5</span>
    <span class="c"># converts from K - &gt; ergs</span>
    <span class="n">conversionFactor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k_CGS</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">kmInCm</span> <span class="o">/</span> <span class="p">(</span> <span class="n">cInCm</span> <span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">/</span> <span class="n">conversionFactor</span>
    <span class="k">if</span> <span class="n">toErg</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">factor</span>
    <span class="k">if</span> <span class="n">toErg</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">factor</span>

<span class="k">def</span> <span class="nf">Int2Lum</span><span class="p">(</span><span class="n">distance_in_pc</span><span class="p">,</span> <span class="n">cm_or_m</span><span class="o">=</span><span class="s">&#39;cm&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Conversion factor to calculate luminosity from intensities </span>
<span class="sd">    by integrating over the sky 4 pi Distance^2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distance_in_pc: float</span>
<span class="sd">        Distance to the source in parsecs.</span>
<span class="sd">    cm_or_m: string</span>
<span class="sd">        Choose wether the out put is in cm^2 = ``&#39;cm&#39;`` or in </span>
<span class="sd">        m^2 = ``&#39;m&#39;``.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Approved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cm_or_m</span> <span class="o">==</span> <span class="s">&#39;m&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance_in_pc</span> <span class="o">*</span> <span class="n">parsecInMeter</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">cm_or_m</span> <span class="o">==</span> <span class="s">&#39;cm&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span> <span class="n">distance_in_pc</span> <span class="o">*</span> <span class="n">parsecInCentiMeter</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">JyBToErgsB</span><span class="p">(</span><span class="n">input_flux</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">wavelenght</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Conversion between Jy/beam and ergs/beam.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    input_flux: float</span>
<span class="sd">        Flux to be converted in Jy/beam</span>
<span class="sd">    distance:float</span>
<span class="sd">        Distance to the source in parsec.</span>
<span class="sd">    wavelenght: float</span>
<span class="sd">        Wavelenght :math:`\lambda` in :math:`\mu m`.</span>
<span class="sd">    r&quot;&quot;&quot;</span>
    <span class="c"># change from Jansky to erg s-1 cm-2 Hz-1</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">JanskyToErgs</span>
    <span class="c"># integrate over sky ergs s-1 Hz-1</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">Int2Lum</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">cmORm</span><span class="o">=</span><span class="s">&#39;cm&#39;</span><span class="p">)</span>
    <span class="c"># multiply by frequency </span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">*</span> <span class="n">conversion</span>
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">/</span> <span class="n">conversion</span>

<span class="k">def</span> <span class="nf">JyBToWM2Kpc2</span><span class="p">(</span><span class="n">input_flux</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">wavelenght</span><span class="p">,</span> 
                 <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Conversion between Jy/beam and W m^-2 kpc^-2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    input_flux:  float</span>
<span class="sd">        Flux to be converted.</span>
<span class="sd">    distance: float</span>
<span class="sd">        Distance to source in parsec.</span>
<span class="sd">    major: float</span>
<span class="sd">        Major Axis Beam (arcsec).</span>
<span class="sd">    minor: float</span>
<span class="sd">        Minor Axis Beam(arcsec).</span>
<span class="sd">    wavelenght: float</span>
<span class="sd">        Wavelenght :math:`\lambda` in :math:`\mu m` </span>
<span class="sd">    invert: True or False</span>
<span class="sd">        Changes the direction of conversion.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    float: the converted Flux.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># change to W/m2/Hz/beam </span>
    <span class="n">conversion</span> <span class="o">=</span>  <span class="n">JanskyToWatt</span>
    <span class="c"># calculate the beamsize in kpc2</span>
    <span class="n">beamsize</span> <span class="o">=</span> <span class="mf">1.133</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="mf">1e3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">major</span> <span class="o">*</span> <span class="n">minor</span> <span class="o">*</span> <span class="n">arcsecInRad</span> <span class="o">**</span><span class="mi">2</span>
    <span class="n">beamsInKpc2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">beamsize</span>
    <span class="c"># change to W/m2/Hz/kpc2</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">beamsInKpc2</span>
    <span class="c">#change to W/m2/kpc2</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">*</span> <span class="n">conversion</span>
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">/</span> <span class="n">conversion</span>

<span class="k">def</span> <span class="nf">JyBToWKpc2</span><span class="p">(</span><span class="n">input_flux</span><span class="p">,</span> <span class="n">Distance</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> 
               <span class="n">wavelenght</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Conversion from JyB to W kpc^-2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    input_flux:  float</span>
<span class="sd">        Flux to be converted.</span>
<span class="sd">    distance: float</span>
<span class="sd">        Distance to source in parsec.</span>
<span class="sd">    major: float</span>
<span class="sd">        Major Axis Beam (arcsec).</span>
<span class="sd">    minor: float</span>
<span class="sd">        Minor Axis Beam(arcsec).</span>
<span class="sd">    wavelenght: float</span>
<span class="sd">        Wavelenght :math:`\lambda` in :math:`\mu m`.</span>
<span class="sd">    invert: True or False</span>
<span class="sd">        Changes the direction of conversion.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    float: the converted Flux.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conversion</span> <span class="o">=</span>  <span class="n">JanskyToWatt</span>          <span class="c"># change to W/m2/Hz/beam </span>
    <span class="n">beamsize</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.133</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">Distance</span> <span class="o">/</span> <span class="mf">1e3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="n">major</span>
                <span class="o">*</span> <span class="n">minor</span>
                <span class="o">*</span> <span class="n">a2r</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># calculate the beamize in kpc2</span>
    <span class="n">beamsInKpc2</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">beamsize</span>  
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">beamsInKpc2</span> <span class="c"># change to W/m2/Hz/kpc2</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="c">#change to W/m2/kpc2</span>
    <span class="n">conversion</span> <span class="o">=</span> <span class="n">conversion</span> <span class="o">*</span> <span class="n">Int2Lum</span><span class="p">(</span><span class="n">Distance</span><span class="p">,</span> <span class="n">cmORm</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">)</span> <span class="c">#change to W/kpc2</span>
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span><span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">*</span> <span class="n">conversion</span>
    <span class="k">if</span> <span class="n">invert</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_flux</span> <span class="o">/</span> <span class="n">conversion</span>
</pre></div>
</td></tr></table></div>
<span class="target" id="module-astrolyze.functions.units"></span><dl class="function">
<dt id="astrolyze.functions.units.Int2Lum">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">Int2Lum</tt><big>(</big><em>distance_in_pc</em>, <em>cm_or_m='cm'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.Int2Lum" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion factor to calculate luminosity from intensities 
by integrating over the sky 4 pi Distance^2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>distance_in_pc: float</strong> :</p>
<blockquote>
<div><p>Distance to the source in parsecs.</p>
</div></blockquote>
<p><strong>cm_or_m: string</strong> :</p>
<blockquote>
<div><p>Choose wether the out put is in cm^2 = <tt class="docutils literal"><span class="pre">'cm'</span></tt> or in 
m^2 = <tt class="docutils literal"><span class="pre">'m'</span></tt>.</p>
</div></blockquote>
<p><strong>Notes</strong> :</p>
<p><strong>&#8212;&#8211;</strong> :</p>
<p class="last"><strong>Approved.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.JyBToErgsB">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">JyBToErgsB</tt><big>(</big><em>input_flux</em>, <em>distance</em>, <em>wavelenght</em>, <em>invert=False</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.JyBToErgsB" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion between Jy/beam and ergs/beam.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>input_flux: float</strong> :</p>
<blockquote>
<div><p>Flux to be converted in Jy/beam</p>
</div></blockquote>
<p><strong>distance:float</strong> :</p>
<blockquote>
<div><p>Distance to the source in parsec.</p>
</div></blockquote>
<p><strong>wavelenght: float</strong> :</p>
<blockquote>
<div><p>Wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> in <img class="math" src="_images/math/d8d39104c7cc0ff9b25486c633d86a35befc3aa6.png" alt="\mu m"/>.</p>
</div></blockquote>
<p class="last"><strong>r</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.JyBToWKpc2">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">JyBToWKpc2</tt><big>(</big><em>input_flux</em>, <em>Distance</em>, <em>major</em>, <em>minor</em>, <em>wavelenght</em>, <em>invert=False</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.JyBToWKpc2" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from JyB to W kpc^-2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>input_flux:  float</strong> :</p>
<blockquote>
<div><p>Flux to be converted.</p>
</div></blockquote>
<p><strong>distance: float</strong> :</p>
<blockquote>
<div><p>Distance to source in parsec.</p>
</div></blockquote>
<p><strong>major: float</strong> :</p>
<blockquote>
<div><p>Major Axis Beam (arcsec).</p>
</div></blockquote>
<p><strong>minor: float</strong> :</p>
<blockquote>
<div><p>Minor Axis Beam(arcsec).</p>
</div></blockquote>
<p><strong>wavelenght: float</strong> :</p>
<blockquote>
<div><p>Wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> in <img class="math" src="_images/math/d8d39104c7cc0ff9b25486c633d86a35befc3aa6.png" alt="\mu m"/>.</p>
</div></blockquote>
<p><strong>invert: True or False</strong> :</p>
<blockquote>
<div><p>Changes the direction of conversion.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>float: the converted Flux.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.JyBToWM2Kpc2">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">JyBToWM2Kpc2</tt><big>(</big><em>input_flux</em>, <em>distance</em>, <em>major</em>, <em>minor</em>, <em>wavelenght</em>, <em>invert=False</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.JyBToWM2Kpc2" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion between Jy/beam and W m^-2 kpc^-2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>input_flux:  float</strong> :</p>
<blockquote>
<div><p>Flux to be converted.</p>
</div></blockquote>
<p><strong>distance: float</strong> :</p>
<blockquote>
<div><p>Distance to source in parsec.</p>
</div></blockquote>
<p><strong>major: float</strong> :</p>
<blockquote>
<div><p>Major Axis Beam (arcsec).</p>
</div></blockquote>
<p><strong>minor: float</strong> :</p>
<blockquote>
<div><p>Minor Axis Beam(arcsec).</p>
</div></blockquote>
<p><strong>wavelenght: float</strong> :</p>
<blockquote>
<div><p>Wavelenght <img class="math" src="_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> in <img class="math" src="_images/math/d8d39104c7cc0ff9b25486c633d86a35befc3aa6.png" alt="\mu m"/></p>
</div></blockquote>
<p><strong>invert: True or False</strong> :</p>
<blockquote>
<div><p>Changes the direction of conversion.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first last"><strong>float: the converted Flux.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.WmToKkms">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">WmToKkms</tt><big>(</big><em>x</em>, <em>resolution=0</em>, <em>sterad=False</em>, <em>ToKKms=False</em>, <em>m2_or_cm2='m'</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.WmToKkms" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion between W/m2 and K km/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float</strong> :</p>
<blockquote>
<div><p>wavelenght/frequency [GHZ].</p>
</div></blockquote>
<p><strong>resolution: float</strong> :</p>
<p><strong>ToKKms: True or False</strong> :</p>
<blockquote>
<div><p>Direction of the conversion.</p>
</div></blockquote>
<p><strong>sterad: True or False</strong> :</p>
<blockquote>
<div><p>If False convert from per beam to per sterad.</p>
</div></blockquote>
<p><strong>m2_or_cm2: string</strong> :</p>
<blockquote class="last">
<div><p>Choose if conversion to/from W m-2 oder W cm-2. <tt class="docutils literal"><span class="pre">'m2'</span></tt> or <tt class="docutils literal"><span class="pre">'cm2'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.ergToKkms">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">ergToKkms</tt><big>(</big><em>x</em>, <em>toErg=False</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.ergToKkms" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion between ergs/cm2/s/sr and K km/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float</strong> :</p>
<blockquote>
<div><p>wavelenght/frequency [GHZ],</p>
</div></blockquote>
<p><strong>toErg: True or False</strong> :</p>
<blockquote>
<div><p>True converts the other direction, i.e. from K km/s to ergs/cm2/s/sr.</p>
</div></blockquote>
<p><strong>nu_or_lambda: string</strong> :</p>
<blockquote class="last">
<div><p>Choose type of x: frequency = <tt class="docutils literal"><span class="pre">'nu'</span></tt> or wavelenght = <tt class="docutils literal"><span class="pre">'lambda'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Approved.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.jansky_to_kelvin">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">jansky_to_kelvin</tt><big>(</big><em>x</em>, <em>major</em>, <em>minor</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.jansky_to_kelvin" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from Jy/beam to K.km/s (Tmb).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float</strong> :</p>
<blockquote>
<div><p>wavelenght/frequency [GHZ],</p>
</div></blockquote>
<p><strong>major: float</strong> :</p>
<blockquote>
<div><p>Major Axis Beam (arcsec).</p>
</div></blockquote>
<p><strong>minor: float</strong> :</p>
<blockquote>
<div><p>Minor Axis Beam(arcsec).</p>
</div></blockquote>
<p><strong>nu_or_lambda: string</strong> :</p>
<blockquote class="last">
<div><p>Choose type of x: frequency = <tt class="docutils literal"><span class="pre">'nu'</span></tt> or wavelenght = <tt class="docutils literal"><span class="pre">'lambda'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Approved.</p>
</dd></dl>

<dl class="function">
<dt id="astrolyze.functions.units.kelvin_to_jansky">
<tt class="descclassname">astrolyze.functions.units.</tt><tt class="descname">kelvin_to_jansky</tt><big>(</big><em>x</em>, <em>major</em>, <em>minor</em>, <em>nu_or_lambda='nu'</em><big>)</big><a class="headerlink" href="#astrolyze.functions.units.kelvin_to_jansky" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from K.km/s (Tmb) and Jy/beam.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x: float</strong> :</p>
<blockquote>
<div><p>wavelenght/frequency [GHZ],</p>
</div></blockquote>
<p><strong>major: float</strong> :</p>
<blockquote>
<div><p>Major Axis Beam (arcsec),</p>
</div></blockquote>
<p><strong>minor: float</strong> :</p>
<blockquote>
<div><p>Minor Axis Beam(arcsec),</p>
</div></blockquote>
<p><strong>nu_or_lambda: string</strong> :</p>
<blockquote class="last">
<div><p>Choose type of x: frequency = <tt class="docutils literal"><span class="pre">'nu'</span></tt> or wavelenght = <tt class="docutils literal"><span class="pre">'lambda'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function has been compared with the Time estimator from the
[GILDAS] package ASTRO and yields the same conversion factors.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="gildas" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[GILDAS]</a></td><td>www.iram.fr/IRAMFR/GILDAS</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="constants">
<h2>constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="mf">1.3806503e-23</span> <span class="c"># Boltzman constant [m^2 kg s^-1 K^-1]</span>
<span class="n">tBG</span> <span class="o">=</span> <span class="mf">2.7</span> <span class="c"># Cosmic Microwave Background Temperature in [K]</span>

<span class="c"># in CGS</span>
<span class="n">k_CGS</span> <span class="o">=</span> <span class="mf">1.3806503e-16</span> <span class="c"># Boltzman constant [cm^2 g s^-1 K^-1]</span>
<span class="n">h_CGS</span> <span class="o">=</span> <span class="mf">6.62606896e-27</span> <span class="c"># Plancks constant [Js]</span>
<span class="n">c_CGS</span><span class="o">=</span><span class="mf">2.99792458e10</span>  <span class="c">#Speed of light [cm]</span>

<span class="n">e</span><span class="o">=</span><span class="mf">2.7182818284</span> <span class="c"># Eulers number </span>

<span class="c"># Distances</span>

<span class="n">parsecInMeter</span> <span class="o">=</span> <span class="mf">3.08568025e16</span> <span class="c"># parsec in m</span>
<span class="n">parsecInCentiMeter</span> <span class="o">=</span> <span class="mf">3.08568025e18</span><span class="c"># parsec in cm</span>

<span class="c"># redundant but maybe used in program parts.</span>
<span class="n">pcInM</span> <span class="o">=</span> <span class="mf">3.085e16</span><span class="c"># parsec in m</span>
<span class="n">pcInCm</span> <span class="o">=</span> <span class="mf">3.08568025e18</span> <span class="c"># parsec in cm</span>

<span class="n">arcsecInRad</span> <span class="o">=</span> <span class="mf">4.848e-6</span> 
<span class="n">arcsecInGrad</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">60.</span><span class="o">/</span><span class="mi">60</span>

<span class="n">squareArcsecInSterad</span> <span class="o">=</span> <span class="mf">4.254517e10</span>

<span class="c">#Masses</span>

<span class="n">mSun</span> <span class="o">=</span> <span class="mf">1.9891e30</span> <span class="c"># [kg]</span>
<span class="n">mProton</span> <span class="o">=</span> <span class="mf">1.672621637e-27</span> <span class="c">#[kg]</span>


<span class="c">#Gauss constants </span>
<span class="c"># GaussArea/(height*FWHM)</span>
<span class="n">gaussConst</span> <span class="o">=</span> <span class="mf">1.064467</span>

<span class="c"># Luminosities</span>

<span class="n">LsunW</span> <span class="o">=</span> <span class="mf">3.846e26</span> <span class="c"># [W]</span>
<span class="n">Lsunergs</span> <span class="o">=</span> <span class="mf">3.846e26</span><span class="o">*</span><span class="mf">1e7</span> <span class="c"># erg/s </span>


<span class="c"># angle Conversions</span>

<span class="c"># a: arseconds</span>
<span class="c"># g: grad</span>
<span class="c"># d: degrees</span>
<span class="c"># r: radian</span>

<span class="n">a2r</span> <span class="o">=</span> <span class="mf">4.848e-6</span>
<span class="n">a2d</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">60</span><span class="o">/</span><span class="mi">60</span>

<span class="n">r2d</span> <span class="o">=</span> <span class="mf">180.</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span>
<span class="n">r2a</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">4.848e-6</span>

<span class="n">d2r</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>
<span class="n">d2a</span> <span class="o">=</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">MapClass</a><ul>
<li><a class="reference internal" href="#mapclassmain">MapClassMain</a></li>
<li><a class="reference internal" href="#mapclassfits">MapClassFits</a></li>
<li><a class="reference internal" href="#mapclassgildas">MapClassGildas</a></li>
<li><a class="reference internal" href="#mapclassmiriad">MapClassMiriad</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-astrolyze.maptools">MapTools</a></li>
<li><a class="reference internal" href="#module-astrolyze.sed">SEDs</a><ul>
<li><a class="reference internal" href="#module-astrolyze.sed.sedCreation">Create SEDs</a></li>
<li><a class="reference internal" href="#module-astrolyze.sed.plotSEDs">Plot SEDs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-astrolyze.functions">Functions</a><ul>
<li><a class="reference internal" href="#module-astrolyze.functions.astroFunctions">astroFunctions</a></li>
<li><a class="reference internal" href="#units">units</a></li>
<li><a class="reference internal" href="#constants">constants</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Documentation of AstroLyze</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/mapClassFits.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Documentation of AstroLyze"
             >previous</a> |</li>
        <li><a href="index.html">AstroLyze 0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Christof Buchbender.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>