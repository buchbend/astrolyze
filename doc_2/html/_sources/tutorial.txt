======
Manual
======

This tutorial explains how astrolyze can be used to ease reduction,
analysis and modification of (radio-)astronomical data and images.

--------

Motivation
==========

First, before we delve into the details, let me give some examples of what
astrolyze is capable of, so that you can decide if it could be of use for you.
This is a snapshot of the most powerful functions of astrolyze; a thorough
introduction with more features and possibilities follows below.

Inter-operating Fits, Gildas and Miriad
--------------------------------------

Using the astrolyze package it is possible to use different file formats and
different programs from within python seamlessly. Say, for the sake of
demonstrations, that you have a Fits image called
``M33_30m_12CO10_Tmb_12.fits`` and that you want to smooth it in miriad to 40
arcsec resolution, re-project it with Gildas to a new central coordinate and
finally convert it back to fits-format:

This is how you would do it with astrolyze::

  from astrolyze import *
  map_ = FitsMap('M33_30m_12CO10_Tmb_12.fits')
  map_ = map_.toMiriad()
  map_ = map_.smooth(40)
  map_ = map_.toGildas()
  map_ = map_.reproject(coordinate=['01:34:50.890', '+31:08:28.03'])
  map_ = map_.toFits()

Please note the special format of the map name. The format follows a certain
``naming convention`` that has to be used with astrolyze. The reason for the
naming conventions and it's internal logic is explained below.

As a side note I use an underscore for the ``map_`` variable, because
otherwise the python function ``map`` is overwritten which may lead to problems.

Changing map units
------------------

With astrolyze the units of a map can be quickly transformed between common
units used in (Radio-) Astronomy (as far as the conversion was implemented
already). Take for example again the ``M33_30m_12CO10_Tmb_12.fits`` map.
Following the naming convention this map is in main beam temperature
(Tmb). Changing its units to ``JyB`` is as easy as::

  from astrolyze import *
  map_ = FitsMap('M33_30m_12CO10_Tmb_12.fits')
  map_ = map_.change_unit('JyB')

Another side note: It's only that easy when astrolyze is set-up
correctly as described in TODO. Link to Installation.  Also please check the
results for plausibility in case there are faults in the interal conversion
algorithms.

Working with stacks of images
-----------------------------

The previous examples show the principles how a single map can be treated in
astrolyze. However the package also includes a way to work on a stack of images
and perform tasks on all of them.

To create a stack, all files that are going to be in the stack have to be
located in one folder (with possible sub-folders NOTE: The functionality with
sub-folders are is however not thoroughly tested however.)
A stack is initialized as follows::

  from astrolyze import *
  example_stack = Stack('path_to_folder')

The maps can be a mix of GILDAS, Fits and MIRIAD maps. The Instance of the
Stack object (here: ``example_stack``) contains a variable called stack which
is a list with Instances of the corresponding maps Objects (GildasMap, FitsMap
and MiriadMap).

The stack module provides several tools to ``unify`` the stack for further
analysis. The maps can be all re-gridded and re-projected to the same central
coordinates, pixel-sizes and dimensions as a given template image via::

  example_stack.unify_dimensions(template='path_to_template_file',
                                  folder='path_to_output_folder')

Also the maps can be all smoothed to the same resolution, by default this is
the largest resolution found in the stack but can also be given manually::

  example_stack.unify_resolution(folder='path_to_output_folder')

Astrolyze includes also some unit conversions that can be used to change all
maps to the same resolutions as long as the input and output units are
programmed. See (TODO) for more details. For the stack::

  example_stack.unify_units(folder='path_to_output_folder')

can be used.

Producing SEDs
--------------

Build on-top of the stack module astrolyze also contains an ``sed`` module
which allows to analyze and plot dust-seds. The SEDs can be read out for an
arbitrary number of positions or for a full maps. In the latter case
temperature and mass maps will be created.

When all maps have the same resolution and dimension (i.e. pixel size and
number) producing temperature maps can be done as follows::

  from astrolyze import *
  sed = SedStack(folder='path_to_input_folder', full_map=True,
                 output_folder='path_to_output_folder')

To generate SEDs at given coordinates it is easiest to provide a separate file
(e.g. ``coordinates.txt``)with the names and coordinates of the positions to be
extracted as follows::

  source_1    1:34:7.00     +30:47:52.00
  source_2    1:33:55.80    +30:43:2.00
  source_3    1:33:52.40    +30:39:18.00
    .              .             .
    .              .             .
    .              .             .

Then a stack of seds can be created::

  from astrolyze import *
  seds = SedStack(folder='path_to_input_folder', flux_acquisition='pixel',)


Comparing Images
----------------

Say you have a number of maps at different resolutions of a galaxy at different
wavelengths and that you want to compare them at the same resolution. Further
say that they are all stored under one folder (with possible sub-folders) and
follow the "Naming Convention" I introduce below. Using the ``maps`` module
this task could be done as follows::

  from astrolyze import *
  map_list = mtools.get_list(folder_with_maps)
  final_resolution = 40
  smooth_folder_to_store_maps = '../any_folder'
  mtools.unify_resolution(map_list, final_resolution, folder,
                          smooth_folder)

Now you may also want to regrid all the maps to the same pixel size and
dimensions to prepare e.g. pixel-to-pixel scatter plots. Deciding on a template
image whose properties are to be applied to the other images this can be done
as follows::

  template = 'path_to_template_image'
  regrid_folder = 'folder to store the modified maps'
  map_list = mtools.get_list(smooth_folder)
  mtools.unifyMaps(map_list, template, regrid_folder)


Not only images ...
-------------------

Last but not least astrolyze is also able to work with 30m class spectra from
within python based on the same principles used to work with
images/maps. Implementation of this feature has however only started...

-------

astrolyze
=========

I started to develop astrolyze to be able to inter-operate the Programs PyFits,
MIRIAD and GILDAS. One reason was that the Gildas task are very
cumbersome to script and once scripted, the scripts are not very flexible. Also
there are some tasks in GILDAS that are (in my opinion) easier to use than in
miriad and vice versa, due to different sets of features.

However, the real power of astrolyze comes from it's internal tracking of
changes to the most important parameters of the maps (or spectral-files), which
are stored directly in the file-names, following a naming-convention.



Naming Convention
=================

A Name that follows the 'Naming Convention' is for example:
``M33_30m-HERA_CO21_Ta*_12_cube_regrid.fits``

All items **MUST** be separated by an underscore (_) and **HAVE** to include at
the following properties in the same order:

1. source
2. telescope
3. species (wavelength OR frequency OR line-name)
4. flux unit
5. resolution

When opening a map with astrolyze these items are transferred to python
variables of the `Map class` (see below).  All additional items
separated by underscores are treated as comments. Comments are not
transferred to individual internal variables of the map objects but are passed
on as a list to the single variable comments.

The last item is followed by the files extension:

* .fits -> FITS
* .gdf, .mean, .velo, .width, .lmv -> GILDAS
* nothing -> MIRIAD (Miriads file format uses directories to store the data.)

Maps that are not following this name convention are **not** supported. This is
to assure that all parts of the program work, since they strongly depend on the
parameters passed on by the file-name, as is explained in this tutorial or the
documentation of the functions.

Using the example file-name above, opening this file with astrolyze as follows::

  from astrolyze import *
  map_ = FitsMap('M33_30m_12CO10_Tmb_12_cube_regrid.fits')

would generate the following python variables::

  map_.source = 'M33'
  map_.telescope = '30m'
  map_.species = '12CO10'
  map_.fluxUnit = 'Tmb'
  map_.resolution = '12'
  map_.comments = ['cube', 'regrid']
  map_.dataFormat = 'fits'

Using one parameter database with line-names, objects and telescope parameters
which can be edited by the user (see description below), astrolyze is able to
pull more information about the object, telescope and line emission of the
map. When the information is present it generates automatically the following
variables::

  map_.frequency
  map_.wavelenght
  map_.calibrationError
  map_.type
  map_.distance
  map_.vlsr
  map_.centralPosition
  map_.pa
  map_.inclination
  map_.R25

If not present in the database these variables are set to 'NaN' (Not a Number).

Although, all of this information is somewhat redundant to the header information in
the files, it has been decided to go that way since unfortunately not all
headers are kept up to date and manipulating the file name is easier to do.

The maps module tries to keep track if a variable that should go into the
header of a fits file is changed and up-dates the header subsequently (Maybe
not true in all cases, though.).

Using this name convention has another benefit since it makes the life of your
fellow astronomers easier when they have to work with your data since they
readily know their most important basic properties.


Modules
=======


astrolyze is divided in different modules and classes which can inter-operate
with each other and which are:

* maps
* spectra
* sed
* functions
* lte

In the following I will introduce the individual modules of astrolyze and their
functionality.


Using maps
==========

The ``maps`` module is the heart of the astrolyze package. It provides the
framework to work with astronomical images (and spectra). It is able to modify
and to track the most important properties of the maps such that they are always
fast at hand if needed. Further it contains genuine functions written in python
(and pyGildas), alongside wrapper functions to functions and tasks of GILDAS_
and MIRIAD_.

Parameter Database
==================

The parameter database is an sqlite database which stores additional
information that is accessed, using the file-name parameters.  During the
installation of astrolyze the database is created in ``~/.astrolyze/database/``
(This is unfortunately at the moment not customizable). The contents of this
database can be set-up before installation of astrolyze in: TODO: Describe how.

The database ``parameter.db`` has three tables: Lines, Galaxies (TBD:should be
objects*), and cal_error. The first table uses line names given in the file
name such as e.g. ``12CO10`` to access information of the frequency and
wavelengths of the lines. The second table ``Galaxies`` uses the source
information from the naming convention to pull information of the:
distance, central coordinate, R_25, morphology type, position angle,
Inclination and velocity (VLSR) of the Galaxy (TBD: Source).

Please see **installation Add link here** for information on how to generate
and update these tables.

Using SED
=========

The module SED makes extensive use of the stack functionality of the maps
module...

Using Functions
===============

The module ``functions`` contains all functions that are not directly related
to manipulation of maps or spectra and counter intuitive also all constants used
in astrolyze as long as they are not available by the standard python
installation (this may not be true however.).



Using LTE
=========


References
==========

.. [GILDAS] www.iram.fr/IRAMFR/GILDAS
.. [MIRIAD] www.atnf.csiro.au/computing/sof tware/miriad/taskindex.html
